{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#about","title":"About","text":""},{"location":"#what-is-mainflux","title":"What is Mainflux?","text":"<p>Mainflux is modern, scalable, secure open source and patent-free IoT cloud platform written in Go.</p> <p>It accepts user and thing connections over various network protocols (i.e. HTTP, MQTT, WebSocket, CoAP), thus making a seamless bridge between them. It is used as the IoT middleware for building complex IoT solutions.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Protocol bridging (i.e. HTTP, MQTT, WebSocket, CoAP)</li> <li>Device management and provisioning</li> <li>Fine-grained access control</li> <li>Platform logging and instrumentation support</li> <li>Container-based deployment using Docker</li> </ul>"},{"location":"#contributing-to-mainflux","title":"Contributing to Mainflux","text":"<p>Thank you for your interest in Mainflux and the desire to contribute!</p> <p>Take a look at our open issues. The good-first-issue label is specifically for issues that are great for getting started. Checkout the contribution guide to learn more about our style and conventions. Make your changes compatible to our workflow.</p>"},{"location":"#license","title":"License","text":"<p>Apache-2.0</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#reference","title":"Reference","text":"<p>API reference in the Swagger UI can be found at:</p> <p>https://api.mainflux.io</p>"},{"location":"api/#users","title":"Users","text":""},{"location":"api/#create-user","title":"Create User","text":"<p>To start working with the Mainflux system, you need to create a user account.</p> <p>Must-have: e-mail and password (password must contain at least 8 characters)</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/users -d '{\"email\":\"&lt;user_email&gt;\", \"password\":\"&lt;user_password&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:06:45 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /users/d782b42b-e317-4cd7-9dd0-4e2ea0f349c8\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n</code></pre>"},{"location":"api/#create-token","title":"Create Token","text":"<p>To log in to the Mainflux system, you need to create a <code>user_token</code>.</p> <p>Must-have: registered e-mail and password</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/tokens -d '{\"email\":\"&lt;user_email&gt;\",\n\"password\":\"&lt;user_password&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:07:18 GMT\nContent-Type: application/json\nContent-Length: 281\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n\n{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTU0MjQ4MzgsImlhdCI6MTYxNTM4ODgzOCwiaXNzIjoibWFpbmZsdXguYXV0aCIsInN1YiI6InRlc3RAZW1haWwuY29tIiwiaXNzdWVyX2lkIjoiZDc4MmI0MmItZTMxNy00Y2Q3LTlkZDAtNGUyZWEwZjM0OWM4IiwidHlwZSI6MH0.TAQxV6TImKw06RsK0J11rOHiWPvexEOA4BNZnhLhtxs\"}\n</code></pre>"},{"location":"api/#get-user","title":"Get User","text":"<p>You can always check the user entity that is logged in by entering the user ID and <code>user_token</code>.</p> <p>Must-have: <code>user_id</code> and <code>user_token</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/users/&lt;user_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:09:47 GMT\nContent-Type: application/json\nContent-Length: 85\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n\n{\"id\":\"d782b42b-e317-4cd7-9dd0-4e2ea0f349c8\",\"email\":\"test@email.com\"}\n</code></pre>"},{"location":"api/#get-users","title":"Get Users","text":"<p>You can get all users in the database by querying this endpoint. List all users request accepts limit, offset, email and metadata query parameters.</p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/users\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:11:28 GMT\nContent-Type: application/json\nContent-Length: 217\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n\n{\"total\":2,\"offset\":0,\"limit\":10,\"Users\":[{\"id\":\"4bf4a13a-e9c3-4207-aa11-fe569986c301\",\"email\":\"admin@example.com\"},{\"id\":\"d782b42b-e317-4cd7-9dd0-4e2ea0f349c8\",\"email\":\"test@email.com\"}]}\n</code></pre> <p>If you want to paginate your results then use this</p> <p>Must have: <code>user_token</code> Additional parameters: <code>offset</code>, <code>limit</code> and <code>email</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/users?offset=&lt;offset&gt;&amp;limit=&lt;limit&gt;&amp;email=&lt;email&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:11:28 GMT\nContent-Type: application/json\nContent-Length: 217\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n\n{\"total\":2,\"offset\":0,\"limit\":10,\"Users\":[{\"id\":\"4bf4a13a-e9c3-4207-aa11-fe569986c301\",\"email\":\"admin@example.com\"},{\"id\":\"d782b42b-e317-4cd7-9dd0-4e2ea0f349c8\",\"email\":\"test@email.com\"}]}\n</code></pre>"},{"location":"api/#update-user","title":"Update User","text":"<p>Updating user's metadata</p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X PUT -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/users -d\n'{\"metadata\":{\"foo\":\"bar\"}}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:15:31 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n</code></pre>"},{"location":"api/#change-password","title":"Change Password","text":"<p>Changing the user password can be done by calling the update password function</p> <p>Must-have: <code>user_token</code>, <code>old_password</code> and password (<code>new_password</code>)</p> <pre><code>curl -s -S -i -X PATCH -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/password -d '{\"old_password\":\"&lt;old_password&gt;\", \"password\":\"&lt;new_password&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:17:36 GMT\nContent-Type: application/json\nContent-Length: 11\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n</code></pre>"},{"location":"api/#enable-user","title":"Enable User","text":"<p>Changing the user status to enabled can be done by calling the enable user function</p> <p>Must-have: <code>user_id</code> and <code>user_token</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/users/&lt;user_id&gt;/enable\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nServer: nginx/1.20.0\nDate: Thu, 18 Aug 2022 13:28:39 GMT\nContent-Type: application/json\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n</code></pre>"},{"location":"api/#disable-user","title":"Disable User","text":"<p>Changing the user status to disabled can be done by calling the disable user function</p> <p>Must-have: <code>user_id</code> and <code>user_token</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/users/&lt;user_id&gt;/disable\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nServer: nginx/1.20.0\nDate: Thu, 18 Aug 2022 13:28:20 GMT\nContent-Type: application/json\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n</code></pre>"},{"location":"api/#things","title":"Things","text":""},{"location":"api/#create-thing","title":"Create Thing","text":"<p>To create a thing, you need the thing and a <code>user_token</code></p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things -d '{\"name\": \"&lt;thing_name&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.20.0\nDate: Wed, 12 Jan 2022 14:20:05 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /things/647216d6-2f02-4358-9752-afffbf12a642\nWarning-Deprecated: This endpoint will be depreciated in v1.0.0. It will be replaced with the bulk endpoint currently found at /things/bulk.\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#create-thing-with-external-id","title":"Create Thing with External ID","text":"<p>It is often the case that the user will want to integrate the existing solutions, e.g. an asset management system, with the Mainflux platform. To simplify the integration between the systems and avoid artificial cross-platform reference, such as special fields in Mainflux Things metadata, it is possible to set Mainflux Thing ID with an existing unique ID while create the Thing. This way, the user can set the existing ID as the Thing ID of a newly created Thing to keep reference between Thing and the asset that Thing represents. There are two limitations - the existing ID have to be in UUID V4 format and it has to be unique in the Mainflux domain.</p> <p>To create a thing with an external ID, you need provide the UUID v4 format ID together with thing name, and other fields as well as a <code>user_token</code></p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things/bulk -d '[{\"id\": \"&lt;thing_id&gt;\",\"name\": \"&lt;thing_name&gt;\"}]'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:18:37 GMT\nContent-Type: application/json\nContent-Length: 119\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"things\":[{\"id\":\"4328f3e4-4c67-40b3-9491-0ab782c48d50\",\"name\":\"thing_name\",\"key\":\"659aa6ca-1781-4a69-9a20-689ddb235506\"}]}\n</code></pre>"},{"location":"api/#create-things","title":"Create Things","text":"<p>You can create multiple things at once by entering a series of things structures and a <code>user_token</code></p> <p>Must-have: <code>user_token</code> and at least two things</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things/bulk -d '[{\"name\": \"&lt;thing_name_1&gt;\"}, {\"name\": \"&lt;thing_name_2&gt;\"}]'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:19:48 GMT\nContent-Type: application/json\nContent-Length: 227\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"things\":[{\"id\":\"4328f3e4-4c67-40b3-9491-0ab782c48d50\",\"name\":\"thing_name_1\",\"key\":\"828c6985-c2d6-419e-a124-ba99147b9920\"},{\"id\":\"38aa33fe-39e5-4ee3-97ba-4227cfac63f6\",\"name\":\"thing_name_2\",\"key\":\"f73e7342-06c1-499a-9584-35de495aa338\"}]}\n</code></pre>"},{"location":"api/#create-things-with-external-id","title":"Create Things with external ID","text":"<p>The same as creating a Thing with external ID the user can create multiple things at once by providing UUID v4 format unique ID in a series of things together with a <code>user_token</code></p> <p>Must-have: <code>user_token</code> and at least two things</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things/bulk -d '[{\"id\": \"&lt;thing_id_1&gt;\",\"name\": \"&lt;thing_name_1&gt;\"},{\"id\": \"&lt;thing_id_2&gt;\",\"name\": \"&lt;thing_name_2&gt;\"}]'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:19:48 GMT\nContent-Type: application/json\nContent-Length: 227\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"things\":[{\"id\":\"&lt;thing_id_1&gt;\",\"name\":\"thing_name_1\",\"key\":\"828c6985-c2d6-419e-a124-ba99147b9920\"},{\"id\":\"&lt;thing_id_2&gt;\",\"name\":\"thing_name_2\",\"key\":\"f73e7342-06c1-499a-9584-35de495aa338\"}]}\n</code></pre>"},{"location":"api/#get-thing","title":"Get Thing","text":"<p>You can get thing entity by entering the thing ID and <code>user_token</code></p> <p>Must-have: <code>user_token</code> and <code>thing_id</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things/&lt;thing_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:20:52 GMT\nContent-Type: application/json\nContent-Length: 106\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"64140f0b-6448-41cf-967e-1bbcc703c332\",\"name\":\"thing_name\",\"key\":\"659aa6ca-1781-4a69-9a20-689ddb235506\"}\n</code></pre>"},{"location":"api/#get-things","title":"Get Things","text":"<p>You can get all things in the database by querying this endpoint. List all things request accepts limit, offset, name and metadata query parameters.</p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:21:49 GMT\nContent-Type: application/json\nContent-Length: 391\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"total\":3,\"offset\":0,\"limit\":10,\"order\":\"\",\"direction\":\"\",\"things\":[{\"id\":\"64140f0b-6448-41cf-967e-1bbcc703c332\",\"name\":\"thing_name\",\"key\":\"659aa6ca-1781-4a69-9a20-689ddb235506\"},{\"id\":\"4328f3e4-4c67-40b3-9491-0ab782c48d50\",\"name\":\"thing_name_1\",\"key\":\"828c6985-c2d6-419e-a124-ba99147b9920\"},{\"id\":\"38aa33fe-39e5-4ee3-97ba-4227cfac63f6\",\"name\":\"thing_name_2\",\"key\":\"f73e7342-06c1-499a-9584-35de495aa338\"}]}\n</code></pre> <p>If you want to paginate your results then use this</p> <p>Must have: <code>user_token</code> Additional parameters: <code>offset</code>, <code>limit</code> and <code>name</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things?offset=&lt;offset&gt;&amp;limit=&lt;limit&gt;&amp;name=&lt;name&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:21:49 GMT\nContent-Type: application/json\nContent-Length: 391\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"total\":3,\"offset\":0,\"limit\":10,\"order\":\"\",\"direction\":\"\",\"things\":[{\"id\":\"64140f0b-6448-41cf-967e-1bbcc703c332\",\"name\":\"thing_name\",\"key\":\"659aa6ca-1781-4a69-9a20-689ddb235506\"},{\"id\":\"4328f3e4-4c67-40b3-9491-0ab782c48d50\",\"name\":\"thing_name_1\",\"key\":\"828c6985-c2d6-419e-a124-ba99147b9920\"},{\"id\":\"38aa33fe-39e5-4ee3-97ba-4227cfac63f6\",\"name\":\"thing_name_2\",\"key\":\"f73e7342-06c1-499a-9584-35de495aa338\"}]}\n</code></pre>"},{"location":"api/#update-thing","title":"Update Thing","text":"<p>Updating a thing entity</p> <p>Must-have: <code>user_token</code> and <code>thing_id</code></p> <pre><code>curl -s -S -i -X PUT -H \"Content-Type: application/json\" -H  \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things/&lt;thing_id&gt; -d '{\"name\": \"&lt;thing_name&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:23:36 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#delete-thing","title":"Delete Thing","text":"<p>To delete a thing you need a <code>thing_id</code> and a <code>user_token</code></p> <p>Must-have: <code>user_token</code> and <code>thing_id</code></p> <pre><code>curl -s -S -i -X DELETE -H \"Content-Type: application/json\" -H  \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/things/&lt;thing_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:24:44 GMT\nContent-Type: application/json\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#channels","title":"Channels","text":""},{"location":"api/#create-channel","title":"Create Channel","text":"<p>To create a channel, you need a <code>user_token</code></p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels -d '{\"name\": \"&lt;channel_name&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:26:51 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /channels/db4b7428-e278-4fe3-b85a-d65554d6abe9\nWarning-Deprecated: This endpoint will be depreciated in v1.0.0. It will be replaced with the bulk endpoint currently found at /channels/bulk.\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#create-channel-with-external-id","title":"Create Channel with external ID","text":"<p>Channel is a group of things that could represent a special category in existing systems, e.g. a building level channel could represent the level of a smarting building system. For helping to keep the reference, it is possible to set an existing ID while creating the Mainflux channel. There are two limitations - the existing ID has to be in UUID V4 format and it has to be unique in the Mainflux domain.</p> <p>To create a channel with external ID, the user needs provide a UUID v4 format unique ID, and a <code>user_token</code></p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels -d '{\"id\": \"&lt;channel_id&gt;\",\"name\": \"&lt;channel_name&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:26:51 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /channels/db4b7428-e278-4fe3-b85a-d65554d6abe9\nWarning-Deprecated: This endpoint will be depreciated in v1.0.0. It will be replaced with the bulk endpoint currently found at /channels/bulk.\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#create-channels","title":"Create Channels","text":"<p>The same as creating a channel with external ID the user can create multiple channels at once by providing UUID v4 format unique ID in a series of channels together with a <code>user_token</code></p> <p>Must-have: <code>user_token</code> and at least 2 channels</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels/bulk -d '[{\"name\": \"&lt;channel_name_1&gt;\"}, {\"name\": \"&lt;channel_name_2&gt;\"}]'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:28:10 GMT\nContent-Type: application/json\nContent-Length: 143\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"channels\":[{\"id\":\"b8073d41-01dc-46ad-bb26-cfecc596c6c1\",\"name\":\"channel_name_1\"},{\"id\":\"2200527a-f590-4fe5-b9d6-892fc6f825c3\",\"name\":\"channel_name_2\"}]}\n</code></pre>"},{"location":"api/#create-channels-with-external-id","title":"Create Channels with external ID","text":"<p>As with things, you can create multiple channels with external ID at once</p> <p>Must-have: <code>user_token</code> and at least 2 channels</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels/bulk -d '[{\"id\": \"&lt;channel_id_1&gt;\",\"name\": \"&lt;channel_name_1&gt;\"}, {\"id\": \"&lt;channel_id_2&gt;\",\"name\": \"&lt;channel_name_2&gt;\"}]'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:28:10 GMT\nContent-Type: application/json\nContent-Length: 143\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"channels\":[{\"id\":\"&lt;channel_id_1&gt;\",\"name\":\"channel_name_1\"},{\"id\":\"&lt;channel_id_2&gt;\",\"name\":\"channel_name_2\"}]}\n</code></pre>"},{"location":"api/#get-channel","title":"Get Channel","text":"<p>Get a channel entity for a logged in user</p> <p>Must-have: <code>user_token</code> and <code>channel_id</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels/&lt;channel_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:29:49 GMT\nContent-Type: application/json\nContent-Length: 63\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"db4b7428-e278-4fe3-b85a-d65554d6abe9\",\"name\":\"channel_name\"}\n</code></pre>"},{"location":"api/#get-channels","title":"Get Channels","text":"<p>You can get all channels in the database by querying this endpoint. List all channels request accepts limit, offset, name and metadata query parameters.</p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:30:34 GMT\nContent-Type: application/json\nContent-Length: 264\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"total\":3,\"offset\":0,\"limit\":10,\"order\":\"\",\"direction\":\"\",\"channels\":[{\"id\":\"db4b7428-e278-4fe3-b85a-d65554d6abe9\",\"name\":\"channel_name\"},{\"id\":\"b8073d41-01dc-46ad-bb26-cfecc596c6c1\",\"name\":\"channel_name_1\"},{\"id\":\"2200527a-f590-4fe5-b9d6-892fc6f825c3\",\"name\":\"channel_name_2\"}]}\n</code></pre>"},{"location":"api/#update-channel","title":"Update Channel","text":"<p>Update channel entity</p> <p>Must-have: <code>user_token</code> and <code>channel_id</code></p> <pre><code>curl -s -S -i -X PUT -H \"Content-Type: application/json\" -H  \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels/&lt;channel_id&gt; -d '{\"name\": \"&lt;channel_name&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:32:08 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#delete-channel","title":"Delete Channel","text":"<p>Delete a channel entity</p> <p>Must-have: <code>user_token</code> and <code>channel_id</code></p> <pre><code>curl -s -S -i -X DELETE -H \"Content-Type: application/json\" -H  \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels/&lt;channel_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:33:21 GMT\nContent-Type: application/json\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#connect","title":"Connect","text":"<p>Connect things to channels</p> <p>Must-have: <code>user_token</code>, <code>channel_id</code> and <code>thing_id</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/connect -d '{\"channel_ids\": [\"&lt;channel_id&gt;\"], \"thing_ids\": [\"&lt;thing_id&gt;\"]}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:36:32 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>Connect thing to channel</p> <p>Must-have: <code>user_token</code>, <code>channel_id</code> and <code>thing_id</code></p> <pre><code>curl -s -S -i -X PUT -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels/&lt;channel_id&gt;/things/&lt;thing_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Fri, 21 Jan 2022 15:20:47 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nWarning-Deprecated: This endpoint will be depreciated in v1.0.0. It will be replaced with the bulk endpoint found at /connect.\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#disconnect","title":"Disconnect","text":"<p>Disconnect things from channels specified by lists of IDs.</p> <p>Must-have: <code>user_token</code>, <code>channel_ids</code> and <code>thing_ids</code></p> <pre><code>curl -s -S -i -X PUT -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:&lt;service_port&gt;/disconnect -d '{\"thing_ids\": [\"&lt;thing_id_1&gt;\", \"&lt;thing_id_2&gt;\"], \"channel_ids\": [\"&lt;channel_id_1&gt;\", \"&lt;channel_id_2&gt;\"]}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nDate: Sun, 11 Jul 2021 17:23:39 GMT\nContent-Length: 0\n</code></pre> <p>Disconnect thing from the channel</p> <p>Must-have: <code>user_token</code>, <code>channel_id</code> and <code>thing_id</code></p> <pre><code>curl -s -S -i -X DELETE -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/channels/&lt;channel_id&gt;/things/&lt;thing_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 15:38:14 GMT\nContent-Type: application/json\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#access-by-key","title":"Access by Key","text":"<p>Checks if thing has access to a channel</p> <p>Must-have: <code>channel_id</code> and <code>thing_key</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/identify/channels/&lt;channel_id&gt;/access-by-key -d '{\"token\": \"&lt;thing_key&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Mon, 22 Mar 2021 13:10:53 GMT\nContent-Type: application/json\nContent-Length: 46\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"d69d0098-072b-41bf-8c6e-ce4dbb12d333\"}\n</code></pre>"},{"location":"api/#access-by-id","title":"Access by ID","text":"<p>Checks if thing has access to a channel</p> <p>Must-have: <code>channel_id</code> and <code>thing_id</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/identify/channels/&lt;channel_id&gt;/access-by-id -d '{\"thing_id\": \"&lt;thing_id&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Mon, 22 Mar 2021 15:02:02 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#identify","title":"Identify","text":"<p>Validates thing's key and returns it's ID if key is valid</p> <p>Must-have: <code>thing_key</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/identify -d '{\"token\": \"&lt;thing_key&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Mon, 22 Mar 2021 15:04:41 GMT\nContent-Type: application/json\nContent-Length: 46\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"d69d0098-072b-41bf-8c6e-ce4dbb12d333\"}\n</code></pre>"},{"location":"api/#messages","title":"Messages","text":""},{"location":"api/#send-messages","title":"Send Messages","text":"<p>Sends message via HTTP protocol</p> <p>Must-have: <code>thing_key</code> and <code>channel_id</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/senml+json\" -H \"Authorization: Thing &lt;thing_key&gt;\" http://localhost/http/channels/&lt;channel_id&gt;/messages -d '[{\"bn\":\"some-base-name:\",\"bt\":1.276020076001e+09,\"bu\":\"A\",\"bver\":5,\"n\":\"voltage\",\"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"t\":-5,\"v\":1.2}, {\"n\":\"current\",\"t\":-4,\"v\":1.3}]'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 202 Accepted\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 16:53:54 GMT\nContent-Length: 0\nConnection: keep-alive\n</code></pre>"},{"location":"api/#read-messages","title":"Read Messages","text":"<p>Reads messages from database for a given channel</p> <p>Must-have: <code>thing_key</code> and <code>channel_id</code></p> <pre><code>curl -s -S -i -H \"Authorization: Thing &lt;thing_key&gt;\" http://localhost:&lt;service_port&gt;/channels/&lt;channel_id&gt;/messages?offset=0&amp;limit=5\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nDate: Wed, 10 Mar 2021 16:54:58 GMT\nContent-Length: 660\n\n{\"offset\":0,\"limit\":10,\"format\":\"messages\",\"total\":3,\"messages\":[{\"channel_name\":\"1a0cde06-8e5c-4f07-aac5-95aff4a19ea0\",\"publisher\":\"33eb28c3-4ca2-45c3-b1c5-d5d049c6c24e\",\"protocol\":\"http\",\"name\":\"some-base-name:voltage\",\"unit\":\"V\",\"time\":1276020076.001,\"value\":120.1},{\"channel_name\":\"1a0cde06-8e5c-4f07-aac5-95aff4a19ea0\",\"publisher\":\"33eb28c3-4ca2-45c3-b1c5-d5d049c6c24e\",\"protocol\":\"http\",\"name\":\"some-base-name:current\",\"unit\":\"A\",\"time\":1276020072.001,\"value\":1.3},{\"channel_name\":\"1a0cde06-8e5c-4f07-aac5-95aff4a19ea0\",\"publisher\":\"33eb28c3-4ca2-45c3-b1c5-d5d049c6c24e\",\"protocol\":\"http\",\"name\":\"some-base-name:current\",\"unit\":\"A\",\"time\":1276020071.001,\"value\":1.2}]}\n</code></pre>"},{"location":"api/#groups","title":"Groups","text":""},{"location":"api/#create-group","title":"Create group","text":"<p>To create a group, you need the group name and a <code>user_token</code></p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/groups -d '{\"name\": \"&lt;group_name&gt;\", \"parent_id\": \"&lt;previous_group_id&gt;\", \"description\": \"&lt;group_description&gt;\", \"metadata\": {}}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 16:58:09 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /groups/01F0EH61SA7C7NDKWYCXVG7PWD\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#members","title":"Members","text":"<p>Get list of ID's from group</p> <p>Must-have: <code>user_token</code> and <code>group_id</code></p> <pre><code>curl -s -S -i -X GET -H 'Content-Type: application/json' -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/groups/&lt;group_id&gt;/members  \n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Tue, 23 Mar 2021 09:18:10 GMT\nContent-Type: application/json\nContent-Length: 116\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"limit\":10,\"total\":0,\"level\":0,\"name\":\"\",\"Members\":[{\"ID\":\"d782b42b-e317-4cd7-9dd0-4e2ea0f349c8\",\"Type\":\"users\"}]}\n</code></pre>"},{"location":"api/#assign","title":"Assign","text":"<p>Assign user, thing or channel to a group</p> <p>Must-have: <code>user_token</code>, <code>group_id</code>, <code>member_id</code> and <code>member_type</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/groups/&lt;group_id&gt;/members -d '{\"members\":[\"&lt;user_id&gt;\" | \"&lt;thing_id_&gt;\" | \"&lt;channel_id_&gt;\"], \"type\":[\"users\" | \"things\" | \"channels\"]}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 17:04:41 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#unassign","title":"Unassign","text":"<p>Unassign user, thing or channel from group</p> <p>Must-have: <code>user_token</code>, <code>group_id</code>, <code>member_id</code> and <code>member_type</code></p> <pre><code>curl -s -S -i -X DELETE -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/groups/&lt;group_id&gt;/members -d '{\"members\":[\"&lt;user_id&gt;\" | \"&lt;thing_id_&gt;\" | \"&lt;channel_id_&gt;\"], \"type\":[\"users\" | \"things\" | \"channels\"]}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 17:13:06 GMT\nContent-Type: application/json\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#get-group","title":"Get group","text":"<p>Get a group entity for a logged in user</p> <p>Must-have: <code>user_token</code> and <code>group_id</code></p> <pre><code>curl -s -S -i -X GET -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/groups/&lt;group_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 17:06:48 GMT\nContent-Type: application/json\nContent-Length: 201\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"01F0EH61SA7C7NDKWYCXVG7PWD\",\"name\":\"group_name\",\"owner_id\":\"d782b42b-e317-4cd7-9dd0-4e2ea0f349c8\",\"level\":0,\"path\":\"\",\"created_at\":\"2021-03-10T16:58:09.579Z\",\"updated_at\":\"2021-03-10T16:58:09.579Z\"}\n</code></pre>"},{"location":"api/#get-groups","title":"Get groups","text":"<p>Get all groups, list requests accepts limit and offset query parameters</p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -s -S -i -X GET -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/groups\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 17:09:28 GMT\nContent-Type: application/json\nContent-Length: 496\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"total\":2,\"level\":0,\"name\":\"\",\"groups\":[{\"id\":\"01F0EH61SA7C7NDKWYCXVG7PWD\",\"name\":\"group_name\",\"owner_id\":\"d782b42b-e317-4cd7-9dd0-4e2ea0f349c8\",\"level\":1,\"path\":\"01F0EH61SA7C7NDKWYCXVG7PWD\",\"created_at\":\"2021-03-10T16:58:09.579Z\",\"updated_at\":\"2021-03-10T16:58:09.579Z\"},{\"id\":\"01F0EHQTP2HQ7JTWZNMVJ0JJCN\",\"name\":\"group_name_1\",\"owner_id\":\"d782b42b-e317-4cd7-9dd0-4e2ea0f349c8\",\"level\":1,\"path\":\"01F0EHQTP2HQ7JTWZNMVJ0JJCN\",\"created_at\":\"2021-03-10T17:07:52.13Z\",\"updated_at\":\"2021-03-10T17:07:52.13Z\"}]}\n</code></pre>"},{"location":"api/#update-group","title":"Update group","text":"<p>Update group entity</p> <p>Must-have: <code>user_token</code> and <code>group_id</code></p> <pre><code>curl -s -S -i -X PUT -H \"Content-Type: application/json\" -H  \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/groups/&lt;group_id&gt; -d '{\"name\": \"&lt;group_name&gt;\"}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 17:11:51 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#delete-group","title":"Delete group","text":"<p>Delete a group entity</p> <p>Must-have: <code>user_token</code> and <code>group_id</code></p> <pre><code>curl -s -S -i -X DELETE -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost/groups/&lt;group_id&gt;\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nServer: nginx/1.16.0\nDate: Wed, 10 Mar 2021 17:14:13 GMT\nContent-Type: application/json\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"api/#share-user-group-with-things-group","title":"Share User Group with Things Group","text":"<p>Adds access rights on thing groups to the user group.</p> <p>Must-have: <code>user_token</code>, <code>user_group_id</code> and <code>&lt;thing_group_id&gt;</code>.</p> <pre><code>curl -s -S -i -X POST http://localhost/groups/&lt;user_group_id&gt;/share -d '{\"thing_group_id\": \"&lt;thing_group_id&gt;\"}' -H 'Content-Type: application/json' -H \"Authorization: Bearer &lt;user_token&gt;\"\n</code></pre> <p>Each user from the group identified by <code>user_group_id</code> will have <code>read</code>, <code>write</code>, and <code>delete</code> policies on the things grouped by <code>thing_group_id</code>. Therefore, they will be able to do operations defined under Things Policies section.</p>"},{"location":"api/#policies","title":"Policies","text":""},{"location":"api/#add-policies","title":"Add policies","text":"<p>The admin can add custom policies. Only policies defined on Predefined Policies section are allowed.</p> <p>Must-have: admin_token, object, subjects_ids and policies</p> <pre><code>curl -isSX POST http://localhost/policies -d '{\"subjects\": [\"&lt;subject_id1&gt;\",...\"&lt;subject_idN&gt;\"], \"object\": \"&lt;object&gt;\", \"policies\": [\"&lt;action_1&gt;, ...\"&lt;action_N&gt;\"]}' -H \"Authorization: Bearer &lt;admin_token&gt;\" -H 'Content-Type: application/json'\n</code></pre> <p>admin_token must belong to the admin.</p> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nContent-Type: application/json\nDate: Wed, 03 Nov 2021 13:00:14 GMT\nContent-Length: 3\n\n{}\n</code></pre>"},{"location":"api/#delete-policies","title":"Delete policies","text":"<p>The admin can delete policies. Only policies defined on Predefined Policies section are allowed.</p> <p>Must-have: admin_token, object, subjects_ids and policies</p> <pre><code>curl -isSX PUT http://localhost/policies -d '{\"subjects\": [\"&lt;subject_id1&gt;\",...\"&lt;subject_idN&gt;\"], \"object\": \"&lt;object&gt;\", \"policies\": [\"&lt;action_1&gt;, ...\"&lt;action_N&gt;\"]}' -H \"Authorization: Bearer &lt;admin_token&gt;\" -H 'Content-Type: application/json'\n</code></pre> <p>admin_token must belong to the admin.</p> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nContent-Type: application/json\nDate: Wed, 03 Nov 2021 13:00:05 GMT\n\n</code></pre>"},{"location":"api/#api-key","title":"API Key","text":""},{"location":"api/#issue-api-key","title":"Issue API Key","text":"<p>Generates a new API key. Then new API key will be uniquely identified by its ID. Duration is expressed in seconds.</p> <p>Must-have: <code>user_token</code></p> <pre><code>curl -isSX POST  http://localhost/keys -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" -d '{\"type\":2, \"duration\":10000}'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nServer: nginx/1.20.0\nDate: Sun, 19 Dec 2021 17:39:44 GMT\nContent-Type: application/json\nContent-Length: 476\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"4d62fb1e-085e-435c-a0c5-5255febfa35b\",\"value\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDAwMzU1ODQsImp0aSI6IjRkNjJmYjFlLTA4NWUtNDM1Yy1hMGM1LTUyNTVmZWJmYTM1YiIsImlhdCI6MTYzOTkzNTU4NCwiaXNzIjoibWFpbmZsdXguYXV0aCIsInN1YiI6ImZscDFAZW1haWwuY29tIiwiaXNzdWVyX2lkIjoiYzkzY2FmYjMtYjNhNy00ZTdmLWE0NzAtMTVjMTRkOGVkMWUwIiwidHlwZSI6Mn0.RnvjhygEPPWFDEUKtfk5okzVhZzOcO0azr8gd5vby5M\",\"issued_at\":\"2021-12-19T17:39:44.175088349Z\",\"expires_at\":\"2021-12-20T21:26:24.175088349Z\"}\n</code></pre>"},{"location":"api/#get-api-key-details","title":"Get API key details","text":"<p>Must-have: 'user_token' and 'key_id'</p> <pre><code>curl -isSX GET  http://localhost/keys/&lt;key_id&gt; -H 'Content-Type: application/json' -H 'Authorization: Bearer &lt;user_token&gt;'\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Sun, 19 Dec 2021 17:43:30 GMT\nContent-Type: application/json\nContent-Length: 218\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"f630f594-d967-4c54-85ef-af58efe8e8ed\",\"issuer_id\":\"c93cafb3-b3a7-4e7f-a470-15c14d8ed1e0\",\"subject\":\"test@email.com\",\"type\":2,\"issued_at\":\"2021-12-19T17:42:40.884521Z\",\"expires_at\":\"2021-12-20T21:29:20.884521Z\"}\n</code></pre>"},{"location":"api/#revoke-api-key-identified-by-the-given-id","title":"Revoke API key identified by the given ID","text":"<p>Must-have: 'user_token' and 'key_id'</p> <pre><code>curl -isSX DELETE  http://localhost/keys/&lt;key_id&gt; -H 'Content-Type: application/json' -H 'Authorization: Bearer &lt;user_token&gt;'  \n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nServer: nginx/1.20.0\nDate: Sun, 19 Dec 2021 17:47:11 GMT\nContent-Type: application/json\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#components","title":"Components","text":"<p>Mainflux IoT platform is comprised of the following services:</p> Service Description users Manages platform's users and auth concerns things Manages platform's things, channels and access policies http-adapter Provides an HTTP interface for accessing communication channels mqtt-adapter Provides an MQTT and MQTT over WS interface for accessing communication channels ws-adapter Provides a WebSocket interface for accessing communication channels coap-adapter Provides a CoAP interface for accessing communication channels opcua-adapter Provides an OPC-UA interface for accessing communication channels lora-adapter Provides a LoRa Server forwarder for accessing communication channels mainflux-cli Command line interface <p></p>"},{"location":"architecture/#domain-model","title":"Domain Model","text":"<p>The platform is built around 3 main entities: users, things and channels.</p> <p><code>User</code> represents the real (human) user of the system. It is represented via its e-mail and password, which he uses as platform access credentials in order to obtain an access token. Once logged into the system, user can manage his resources (i.e. things and channels) in CRUD fashion and define access control policies by connecting them.</p> <p><code>Thing</code> represents devices (or applications) connected to Mainflux that uses the platform for message exchange with other \"things\".</p> <p><code>Channel</code> represents a communication channel. It serves as message topic that can be consumed by all of the things connected to it.</p>"},{"location":"architecture/#messaging","title":"Messaging","text":"<p>Mainflux uses NATS as its default messaging backbone, due to its lightweight and performant nature. You can treat its subjects as physical representation of Mainflux channels, where subject name is constructed using channel unique identifier. Mainflux also provides the ability to change your default message broker to RabbitMQ, VerneMQ or Kafka.</p> <p>In general, there is no constrained put on content that is being exchanged through channels. However, in order to be post-processed and normalized, messages should be formatted using SenML.</p>"},{"location":"architecture/#edge","title":"Edge","text":"<p>Mainflux platform can be run on the edge as well. Deploying Mainflux on a gateway makes it able to collect, store and analyze data, organize and authenticate devices. To connect Mainflux instances running on a gateway with Mainflux in a cloud we can use two gateway services developed for that purpose:</p> <ul> <li>Agent</li> <li>Export</li> </ul>"},{"location":"architecture/#unified-iot-platform","title":"Unified IoT Platform","text":"<p>Running Mainflux on gateway moves computation from cloud towards the edge thus decentralizing IoT system.  Since we can deploy same Mainflux code on gateway and in the cloud there are many benefits but the biggest one is easy deployment and adoption - once the engineers understand how to deploy and maintain the platform, they will have the same known work across the whole edge-fog-cloud continuum. Same set of tools can be used, same patches and bug fixes can be applied. The whole system is much easier to reason about, and the maintenance is much easier and less costly.</p>"},{"location":"authentication/","title":"Authentication","text":""},{"location":"authentication/#user-authentication","title":"User authentication","text":"<p>For user authentication Mainflux uses Authentication keys. There are three types of authentication keys:</p> <ul> <li>User key - keys issued to the user upon login request</li> <li>API key - keys issued upon the user request</li> <li>Recovery key - password recovery key</li> </ul> <p>Authentication keys are represented and distributed by the corresponding JWT. User keys are issued when user logs in. Each user request (other than registration and login) contains user key that is used to authenticate the user.</p> <p>API keys are similar to the User keys. The main difference is that API keys have configurable expiration time. If no time is set, the key will never expire. API keys are the only key type that can be revoked. This also means that, despite being used as a JWT, it requires a query to the database to validate the API key. The user with API key can perform all the same actions as the user with login key (can act on behalf of the user for Thing, Channel, or user profile management), except issuing new API keys. </p> <p>Recovery key is the password recovery key. It's short-lived token used for password recovery process.</p> <p>The following actions are supported:</p> <ul> <li>create (all key types)</li> <li>verify (all key types)</li> <li>obtain (API keys only; secret is never obtained)</li> <li>revoke (API keys only)</li> </ul>"},{"location":"authentication/#authentication-with-mainflux-keys","title":"Authentication with Mainflux keys","text":"<p>By default, Mainflux uses Mainflux Thing keys for authentication. The Thing key is a secret key that's generated at the Thing creation. In order to authenticate, the Thing needs to send its key with the message. The way the key is passed depends on the protocol used to send a message and differs from adapter to adapter. For more details on how this key is passed around, please check out messaging section. This is the default Mainflux authentication mechanism and this method is used if the composition is started using the following command:</p> <pre><code>docker-compose -f docker/docker-compose.yml up\n</code></pre>"},{"location":"authentication/#mutual-tls-authentication-with-x509-certificates","title":"Mutual TLS Authentication with X.509 Certificates","text":"<p>In most of the cases, HTTPS, WSS, MQTTS or secure CoAP are secure enough. However, sometimes you might need an even more secure connection. Mainflux supports mutual TLS authentication (mTLS) based on X.509 certificates. By default, the TLS protocol only proves the identity of the server to the client using the X.509 certificate and the authentication of the client to the server is left to the application layer. TLS also offers client-to-server authentication using client-side X.509 authentication. This is called two-way or mutual authentication. Mainflux currently supports mTLS over HTTP, WS, MQTT and MQTT over WS protocols. In order to run Docker composition with mTLS turned on, you can execute the following command from the project root:</p> <pre><code>AUTH=x509 docker-compose -f docker/docker-compose.yml up -d\n</code></pre> <p>Mutual authentication includes client-side certificates. Certificates can be generated using the simple script provided here. In order to create a valid certificate, you need to create Mainflux thing using the process described in the provisioning section. After that, you need to fetch created thing key. Thing key will be used to create x.509 certificate for the corresponding thing. To create a certificate, execute the following commands:</p> <pre><code>cd docker/ssl\nmake ca CN=&lt;common_name&gt; O=&lt;organization&gt; OU=&lt;organizational_unit&gt; emailAddress=&lt;email_address&gt;\nmake server_cert CN=&lt;common_name&gt; O=&lt;organization&gt; OU=&lt;organizational_unit&gt; emailAddress=&lt;email_address&gt;\nmake thing_cert THING_KEY=&lt;thing_key&gt; CRT_FILE_NAME=&lt;cert_name&gt; O=&lt;organization&gt; OU=&lt;organizational_unit&gt; emailAddress=&lt;email_address&gt;\n</code></pre> <p>These commands use OpenSSL tool, so please make sure that you have it installed and set up before running these commands. The default values for Makefile variables are</p> <pre><code>CRT_LOCATION = certs\nTHING_KEY = d7cc2964-a48b-4a6e-871a-08da28e7883d\nO = Mainflux\nOU = mainflux\nEA = info@mainflux.com\nCN = localhost\nCRT_FILE_NAME = thing\n</code></pre> <p>Normally, in order to get things running, you will need to specify only <code>THING_KEY</code>. The other variables are not mandatory and the termination should work with the default values.</p> <ul> <li>Command <code>make ca</code> will generate a self-signed certificate that will later be used as a CA to sign other generated certificates. CA will expire in 3 years.</li> <li>Command <code>make server_cert</code> will generate and sign (with previously created CA) server cert, which will expire after 1000 days. This cert is used as a Mainflux server-side certificate in usual TLS flow to establish HTTPS or MQTTS connection.</li> <li>Command <code>make thing_cert</code> will finally generate and sign a client-side certificate and private key for the thing.</li> </ul> <p>In this example <code>&lt;thing_key&gt;</code> represents key of the thing and <code>&lt;cert_name&gt;</code> represents the name of the certificate and key file which will be saved in <code>docker/ssl/certs</code> directory. Generated Certificate will expire after 2 years. The key must be stored in the x.509 certificate <code>CN</code> field.  This script is created for testing purposes and is not meant to be used in production. We strongly recommend avoiding self-signed certificates and using a certificate management tool such as Vault for the production.</p> <p>Once you have created CA and server-side cert, you can spin the composition using:</p> <pre><code>AUTH=x509 docker-compose -f docker/docker-compose.yml up -d\n</code></pre> <p>Then, you can create user and provision things and channels. Now, in order to send a message from the specific thing to the channel, you need to connect thing to the channel and generate corresponding client certificate using aforementioned commands. To publish a message to the channel, thing should send following request:</p>"},{"location":"authentication/#wss","title":"WSS","text":"<pre><code>const WebSocket = require('ws');\n// Do not verify self-signed certificates if you are using one.\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'\n// Replace &lt;channel_id&gt; and &lt;thing_key&gt; with real values.\nconst ws = new WebSocket('wss://localhost/ws/channels/&lt;channel_id&gt;/messages?authorization=&lt;thing_key&gt;',\n// This is ClientOptions object that contains client cert and client key in the form of string. You can easily load these strings from cert and key files.\n{\n    cert: `-----BEGIN CERTIFICATE-----....`,\n    key: `-----BEGIN RSA PRIVATE KEY-----.....`\n})\nws.on('open', () =&gt; {\n    ws.send('something')\n})\nws.on('message', (data) =&gt; {\n    console.log(data)\n})\nws.on('error', (e) =&gt; {\n    console.log(e)\n})\n</code></pre> <p>As you can see, <code>Authorization</code> header does not have to be present in the HTTP request, since the key is present in the certificate. However, if you pass <code>Authorization</code> header, it must be the same as the key in the cert. In the case of MQTTS, <code>password</code> filed in CONNECT message must match the key from the certificate. In the case of WSS, <code>Authorization</code> header or <code>authorization</code> query parameter must match cert key.</p>"},{"location":"authentication/#https","title":"HTTPS","text":"<pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt --cert docker/ssl/certs/&lt;thing_cert_name&gt;.crt --key docker/ssl/certs/&lt;thing_cert_key&gt;.key -X POST -H \"Content-Type: application/senml+json\" https://localhost/http/channels/&lt;channel_id&gt;/messages -d '[{\"bn\":\"some-base-name:\",\"bt\":1.276020076001e+09, \"bu\":\"A\",\"bver\":5, \"n\":\"voltage\",\"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"t\":-5,\"v\":1.2}, {\"n\":\"current\",\"t\":-4,\"v\":1.3}]'\n</code></pre>"},{"location":"authentication/#mqtts","title":"MQTTS","text":""},{"location":"authentication/#publish","title":"Publish","text":"<pre><code>mosquitto_pub -u &lt;thing_id&gt; -P &lt;thing_key&gt; -t channels/&lt;channel_id&gt;/messages -h localhost -p 8883  --cafile docker/ssl/certs/ca.crt --cert docker/ssl/certs/&lt;thing_cert_name&gt;.crt --key docker/ssl/certs/&lt;thing_cert_key&gt;.key -m '[{\"bn\":\"some-base-name:\",\"bt\":1.276020076001e+09, \"bu\":\"A\",\"bver\":5, \"n\":\"voltage\",\"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"t\":-5,\"v\":1.2}, {\"n\":\"current\",\"t\":-4,\"v\":1.3}]'\n</code></pre>"},{"location":"authentication/#subscribe","title":"Subscribe","text":"<pre><code>mosquitto_sub -u &lt;thing_id&gt; -P &lt;thing_key&gt; --cafile docker/ssl/certs/ca.crt --cert docker/ssl/certs/&lt;thing_cert_name&gt;.crt --key docker/ssl/certs/&lt;thing_cert_key&gt;.key -t channels/&lt;channel_id&gt;/messages -h localhost -p 8883\n</code></pre>"},{"location":"authorization/","title":"Authorization","text":""},{"location":"authorization/#policies","title":"Policies","text":"<p>Mainflux uses policies to control permissions on entities: users, things, and groups. Under the hood, Mainflux uses ORY Keto that is an open-source implementation of \"Zanzibar: Google's Consistent, Global Authorization System\".</p> <p>Policies define permissions for the entities. For example, which user has access to a specific thing. Such policies have three main components: subject, object, and relation.</p> <p>To put it briefly:</p> <p>Subject: As the name suggests, it is the subject that will have the policy such as users. Mainflux uses entity UUID on behalf of the real entities.</p> <p>Object: Objects are Mainflux entities (e.g. thing or group) represented by their UUID.</p> <p>Relation: This is the action that the subject wants to do on the object.</p> <p>For more conceptual details, you can refer official ORY Keto documentation</p> <p>All three components create a single policy.</p> <p>For example, let's assume we have a following policy: <code>\"user_id_123\" has \"read\" relation on \"thing_id_123\"</code>. This policy means that subject (a user with ID: <code>user_id_123</code>) has a relation (<code>read</code>) on the object (a thing with ID: <code>thing_id_123</code>). Based upon this example, If the user wants to view a <code>Thing</code>, Mainflux first identifies the user with Authentication Keys and checks the policy as:</p> <pre><code>User with ID: `user_id_123` has `read` relation on the thing with ID: `thing_id_123`.\n</code></pre> <p>If the user has no such policy, the operation will be denied; otherwise, the operation will be allowed. In this case, since the user <code>user_id_123</code> has the policy, the <code>read</code> operation on the thing <code>thing_id_123</code> will be allowed for the user with ID <code>user_id_123</code>. On the other hand, requests coming from other users (who have a different ID than <code>user_id_123</code>) will be denied.</p> <p>In order to check whether a user has the policy or not, Mainflux makes a gRPC call to Keto API, then Keto handles the checking existence of the policy.</p> <p>All policies are stored in the Keto Database. The database responsible for storing all policies is deployed along with the Mainflux, as a standalone PostgreSQL database container.</p>"},{"location":"authorization/#predefined-policies","title":"Predefined Policies","text":"<p>Mainflux comes with predefined policies.</p>"},{"location":"authorization/#users-service-related-policies","title":"Users service related policies","text":"<ul> <li>By default, Mainflux allows anybody to create a user. If you disable this default policy, only admin is able to create a user. This default policy can be disabled through an environment variable called <code>MF_USERS_ALLOW_SELF_REGISTER</code> in deployment time. <code>MF_USERS_ALLOW_SELF_REGISTER</code> is a boolean. Therefore, it expects <code>\"true\"</code> or <code>\"false\"</code>. If you assign <code>\"false\"</code> to this environment variable, only admin can create a user. Mainflux creates a special policy to enable this feature as follows: <code>user#create@*</code>. This policy dictates that subject <code>*</code> has <code>create</code> relation on the object <code>users</code>. Here, Mainflux uses a special <code>*</code> subject to represent all users. If this policy is defined, everybody can create new users.</li> <li>All users are a <code>member of the users</code>. To be more precise, once the new user is created, the policy service creates the following policy: <code>users#member@&lt;user_id&gt;</code> indicating that the subject <code>&lt;user_id</code>&gt; has <code>member</code> relation on the object <code>users</code>.</li> <li>The admin has a special policy indicating that the user is admin. This policy is the following: <code>&lt;admin_id&gt;</code> has <code>member</code> relation on the object <code>authorities</code>.</li> </ul>"},{"location":"authorization/#things-service-related-policies","title":"Things service related policies","text":"<ul> <li>There are 3 policies regarding <code>Things</code>: <code>read</code>, <code>write</code> and <code>delete</code>.</li> <li>When a user creates a thing, the user will have <code>read</code>, <code>write</code> and <code>delete</code> policies on the <code>Thing</code>.</li> <li>In order to view a thing, you need <code>read</code> policy on that thing.</li> <li>In order to update and share the thing, you need a <code>write</code> policy on that thing.</li> <li>In order to remove a thing, you need a <code>delete</code> policy on that thing.</li> </ul>"},{"location":"authorization/#group-entity-related-policies","title":"Group entity related policies","text":"<ul> <li>Once the user creates a new group, the user will have a <code>member</code> policy on the group.</li> <li>If you assign a new User member to your group, the new user will have a <code>member</code> policy on this particular group.</li> <li>If you assign a new Thing member to your group, whatever has <code>member</code> policy on that group will have <code>read</code>, <code>write</code> and <code>delete</code> policies on the Things defined in the Group.</li> <li>Mainflux allows users to assign access rights of the Things group with the Users group. Thus, each member of the User group can access Things defined in the Thing group. In order to do so, the Policy service adds members of the User group as a <code>member</code> of the Thing Group. Therefore, the Users group members have <code>read</code>, <code>write</code> and <code>delete</code> policy on the Things defined in the Thing Group.</li> </ul>"},{"location":"authorization/#summary-of-the-defined-policies","title":"Summary of the Defined Policies","text":"<ul> <li><code>member</code>: Identifies registered user's role such as <code>admin</code>. Also, it indicates memberships on the Group entity.</li> <li><code>read</code>, <code>write</code> and <code>delete</code>: Controls access control for the Things.</li> <li><code>create</code>: Mainflux uses special <code>create</code> policy to allow everybody to create new users. If you want to enable this feature through the HTTP, you need to make following request:</li> </ul> <pre><code>curl -isSX POST http://localhost/policies -d '{\"subjects\":[\"*\"],\"policies\": [\"create\"], \"object\": \"user\"}' -H \"Authorization: Bearer &lt;admin_token&gt;\" -H 'Content-Type: application/json'\n</code></pre>"},{"location":"authorization/#add-policies","title":"Add Policies","text":"<p>You can add policies as well through an HTTP endpoint. Only admin can use this endpoint. Therefore, you need an authentication token for the admin.</p> <p>Caveat: Only policies defined under Summary of the Defined Policies are allowed. Other policies are not allowed. For example, you can add <code>member</code> policy but not <code>custom-member</code> policy because <code>custom-member</code> policy is not defined on the system.</p> <pre><code>curl -isSX POST http://localhost/policies -d '{\"subjects\": [\"&lt;subject_id1&gt;\",...\"&lt;subject_idN&gt;\"], \"object\": \"&lt;object&gt;\", \"policies\": [\"&lt;action_1&gt;, ...\"&lt;action_N&gt;\"]}' -H \"Authorization: Bearer &lt;admin_token&gt;\" -H 'Content-Type: application/json'\n</code></pre>"},{"location":"authorization/#delete-policies","title":"Delete Policies","text":"<p>The admin can delete policies. Only policies defined on Predefined Policies section are allowed.</p> <p>Must-have: admin_token, object, subjects_ids and policies</p> <pre><code>curl -isSX PUT http://localhost/policies -d '{\"subjects\": [\"&lt;subject_id1&gt;\",...\"&lt;subject_idN&gt;\"], \"object\": \"&lt;object&gt;\", \"policies\": [\"&lt;action_1&gt;, ...\"&lt;action_N&gt;\"]}' -H \"Authorization: Bearer &lt;admin_token&gt;\" -H 'Content-Type: application/json'\n</code></pre> <p>admin_token must belong to the admin.</p> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\nContent-Type: application/json\nDate: Wed, 03 Nov 2021 13:00:05 GMT\n\n</code></pre> <p>If you delete policies, the policy will be removed from the policy storage. Further authorization checks related to that policy will fail.</p> <p>For example, let's assume <code>user1</code> has <code>read</code> policy on the thing <code>thing-123</code>. If you delete this policy as:</p> <pre><code>curl -isSX PUT http://localhost/policies -d '{\"subjects\": [\"&lt;user1_id&gt;\"], \"object\": \"thing-123\", \"policies\": [\"read\"]}' -H \"Authorization: Bearer &lt;admin_token&gt;\" -H 'Content-Type: application/json'\n</code></pre> <p><code>user1</code> will not be able to view the <code>thing-123</code> anymore because the policy which allows <code>user1</code> to view <code>thing-123</code> is deleted by the admin.</p>"},{"location":"authorization/#example-usage-of-adding-a-policy","title":"Example usage of adding a policy","text":"<p>Suppose we are using the Mainflux version that doesn't have a policies feature yet. Once you migrate a new version of the Mainflux including the Policy feature, your users will face a lack of authorization. For example, there is a user created before the Policy feature. This user is authenticated by <code>&lt;user_token</code>&gt;. Although the following operation is valid, the user will have an authorization error.</p> <pre><code>mainflux-cli things create '{\"name\":\"user-thing\"}' &lt;user_token&gt;\n\nerror: failed to create entity: 403 Forbidden\n</code></pre> <p>The reason is that the user has not enough policy to create a new Thing after migration. In order to create a new thing, the user has to have a <code>member</code> relation on the <code>users</code> key. So that, Mainflux understands that the requester user is authorized to create new Things.</p> <p>The easiest solution for this problem is adding policies for the users through the HTTP endpoint. As described above, the user needs a <code>member</code> relation on the <code>users</code>.</p> <pre><code>curl -isSX POST http://localhost/policies -d '{\"subjects\":[\"&lt;user_id&gt;\"],\"policies\": [\"member\"], \"object\": \"users\"}' -H \"Authorization: Bearer &lt;admin_token&gt; \" -H 'Content-Type: application/json'\n</code></pre> <p>So what this request does is add new policies for the subject defined in the <code>subjects</code> field of the request body. Henceforth, the subject (here <code>&lt;user_id&gt;</code>) will have a <code>member</code> relation on the object <code>users</code>. This policy allows the user to create new Things.</p> <p>Please, keep in mind that this endpoint requires you to use <code>&lt;admin_token&gt;</code>, not any token. So, the token must belong to the admin.</p>"},{"location":"authorization/#example-usage-of-sharing-a-thing","title":"Example usage of sharing a Thing","text":"<p>Let's assume, we have two users (called <code>user1</code> and <code>user2</code>) registered on the system who have <code>user_id_1</code> and <code>user_id_2</code> as their ID respectively. Let's create a thing with the following command:</p> <pre><code>mainflux-cli things create '{\"name\":\"user1-thing\"}' &lt;user1_token&gt;           \n\ncreated: a1109d52-6281-410e-93ae-38ba7daa9381\n</code></pre> <p>This command creates a thing called <code>\"user1-thing\"</code> with ID = <code>a1109d52-6281-410e-93ae-38ba7daa9381</code>. Mainflux identifies the <code>user1</code> by using the <code>&lt;user1_token&gt;</code>. After identifying the requester as <code>user1</code>, the Policy service adds <code>read</code>, <code>write</code> and <code>delete</code> policies to <code>user1</code> on <code>\"user1-thing\"</code>.</p> <p>If <code>user2</code> wants to view the <code>\"user1-thing\"</code>, the request will be denied.</p> <pre><code>mainflux-cli things get a1109d52-6281-410e-93ae-38ba7daa9381 &lt;user2_token&gt;\n\nerror: failed to fetch entity : 403 Forbidden\n</code></pre> <p>After identifying the requester as <code>user2</code>, the Policy service checks that <code>Is user2 allowed to view the \"user1-thing\"?</code> Since <code>user2</code> has no such policy (<code>read</code> policy on <code>\"user1-thing\"</code>), the Policy service denies this request.</p> <p>Now, <code>user1</code> wants to share the <code>\"user1-thing\"</code> with <code>user2</code>. <code>user1</code> can achieve this via HTTP endpoint for sharing things as follows:</p> <pre><code>curl -isSX POST http://localhost/things/a1109d52-6281-410e-93ae-38ba7daa9381/share -d '{\"user_ids\":[\"&lt;user2_id&gt;]\", \"policies\": [\"read\", \"delete\"]}' -H \"Authorization: Bearer &lt;user1_token&gt;\" -H 'Content-Type: application/json'\n\nHTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Thu, 09 Sep 2021 11:36:10 GMT\nContent-Type: application/json\nContent-Length: 3\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{}\n</code></pre> <p>Note: Since sharing a thing requires a <code>write</code> policy on the thing, <code>user2</code> cannot assign a new policy for <code>\"user1-thing\"</code> by itself.</p> <p>Now, <code>user2</code> has <code>read</code> and <code>delete</code> policies on <code>\"user1-thing\"</code> which allows <code>user2</code> to view and delete <code>\"user1-thing\"</code>. However, <code>user2</code> cannot update the <code>\"user1-thing\"</code> because <code>user2</code> has no <code>write</code> policy on <code>\"user1-thing\"</code>.</p> <p>Let's try again viewing the <code>\"user1-thing\"</code> as <code>user2</code>:</p> <pre><code>mainflux-cli things get a1109d52-6281-410e-93ae-38ba7daa9381 &lt;user2_token&gt;\n\n{\n  \"id\": \"a1109d52-6281-410e-93ae-38ba7daa9381\",\n  \"key\": \"6c9c2146-de49-460d-8f0d-adce4ad37500\",\n  \"name\": \"user1-thing\"\n}\n</code></pre> <p>As we expected, the operation is successfully done. The policy server checked that <code>Is user2 allowed to view \"user1-thing\"?</code> Since <code>user2</code> has a <code>read</code> policy on <code>\"user1-thing\"</code>, the Policy server allows this request.</p>"},{"location":"authorization/#example-usage-of-groups","title":"Example usage of Groups","text":"<p>In this scenario, there will be two users called <code>user1@example.com</code> and <code>user2@example.com</code>. <code>user1@example.com</code> will create one Thing called <code>thing-test</code>. Then, the Group entity will be utilized to store all of the created entities (<code>user1@example.com</code>, <code>user2@example.com</code>, and <code>thing-test</code>). At the end of this scenario, we will verify that although <code>user2@example.com</code> has no ownership of <code>thing-test</code>, <code>user2@example.com</code> can access the <code>thing-test</code> because they are in the same group.</p> <p>Let's start with creating users: - Create <code>user1@example.com</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/users -d '{\"email\":\"user1@example.com\", \"password\":\"12345678\"}'\n</code></pre> <ul> <li>Create <code>user2@example.com</code></li> </ul> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/users -d '{\"email\":\"user2@example.com\", \"password\":\"12345678\"}'\n</code></pre> <p>Now, let's create a Thing called <code>thing-test</code> owned by <code>user1@example.com</code>. Prior to creating it, first, obtain a token for <code>user1@example.com</code> as follows:</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/tokens -d '{\"email\":\"user1@example.com\", \"password\":\"12345678\"}'\n</code></pre> <p>It is convenient to store the generated token because the token will be required in further steps repeatedly.</p> <pre><code>export USER1TOKEN=&lt;USER1TOKEN&gt;\n</code></pre> <p>And create a Thing called <code>thing-test</code></p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $USER1TOKEN\" http://localhost/things/bulk -d '[{\"name\": \"thing-test\"}]'\n</code></pre> <p>Note: We will need the ID of newly created Thing in further steps. Again, it is better to store it.</p> <p>If <code>user2@example.com</code> tries to view <code>thing-test</code>, the operation will be denied by policy service because <code>user2@example.com</code> has no policies related to reading <code>thing-test</code>.</p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $USER2TOKEN\" http://localhost/things/&lt;thing_id&gt;\nHTTP/1.1 403 Forbidden\nServer: nginx/1.20.0\nDate: Fri, 05 Nov 2021 06:03:42 GMT\nContent-Type: application/json\nContent-Length: 60\nConnection: keep-alive\n\n{\"error\":\"failed to perform authorization over the entity\"}\n</code></pre> <p>It is time to create a new Group and put all entities into that Group. Mainflux provides HTTP API for Groups like other entities. We will utilize this HTTP API for Group operations. For more details about Groups, please see Groups documentation.</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $USER1TOKEN\" http://localhost/groups -d '{\"name\": \"my_group\"}'\nHTTP/1.1 201 Created\nServer: nginx/1.20.0\nDate: Fri, 05 Nov 2021 06:10:32 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /groups/01FKQBGQEP71DG9C99J37YBJD7\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>The <code>POST /groups</code> API creates a new group. In our case, it creates a group called <code>my_group</code>. Since <code>user1@example.com</code>'s token is used, the policy service creates a policy to indicate that <code>user1@example.com</code> is member of my_group.</p> <p>In the Location response header, you can see the ID of the <code>my_group</code>. For the response above, the location is <code>Location: /groups/01FKQBGQEP71DG9C99J37YBJD7</code>. Therefore, the group ID of <code>my_group</code> is <code>01FKQBGQEP71DG9C99J37YBJD7</code>. We will need this ID while assigning new members to <code>my_group</code>.</p> <p>The group <code>my_group</code> includes just a member that is <code>user1@example.com</code>, yet. In order to add new members, we will use <code>POST /groups/&lt;group_id&gt;/members</code>. While assigning entities, you will need the ID of the entities respectively. Let's start with assigning <code>thing-test</code> to <code>my_group</code>.</p> <pre><code> curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $USER1TOKEN\" http://localhost/groups/&lt;group_id&gt;/members -d '{\"members\":[\"&lt;thing_id&gt;\"], \"type\":\"things\"}'\n</code></pre> <p>The crucial point here is that since we are assigning a Thing to the Group, the <code>\"type\"</code> field of the request body must be <code>things</code>.</p> <p>Now, assign <code>user2@example.com</code> to <code>my_group</code>.</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $USER1TOKEN\" http://localhost/groups/$g/members -d '{\"members\": \"c0fb3fdb-ecfa-407a-bd11-93884d70baf7\"], \"type\":\"users\"}'\n</code></pre> <p>Again, please be careful about the <code>\"type\"</code> field of the request body. Since we are assigning the user, the type is <code>users</code>.</p> <p>Under the hood, the Policy service creates <code>member</code> policies for each entity respectively. Also, each user member will have access to Things defined in the Group. That's why the type field is crucial.</p> <p>Okay, let's check whether <code>user2@example.com</code> is capable to view the <code>my-thing</code>. Previously, the Policy service denied that request from <code>user2@example.com</code>. Try again:</p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $USER2TOKEN\" http://localhost/things/&lt;thing_id&gt;\nHTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Fri, 05 Nov 2021 06:36:03 GMT\nContent-Type: application/json\nContent-Length: 111\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"7d551538-834d-4398-bd4d-38940dd4bfa9\",\"name\":\"thing-test\",\"key\":\"4305f78d-399b-4cc4-ad42-3fd5bac09715\"}\n</code></pre> <p>Successful as we expected. Since <code>user2@example.com</code> and <code>my-thing</code> reside in the same group, <code>user2@example.com</code> can access the <code>my-thing</code> through Group policies.</p> <p>If you unassign user2@example.com, the user cannot access <code>my-thing</code>. In order to test it, you can unassign the <code>user2@example.com</code> as follows:</p> <pre><code>curl -s -S -i -X DELETE -H \"Content-Type: application/json\" -H \"Authorization: Bearer $USER1TOKEN\" http://localhost/groups/$g/members -d '{\"members\": \"c0fb3fdb-ecfa-407a-bd11-93884d70baf7\"], \"type\":\"users\"}'\n</code></pre> <p>Since <code>user2@example.com</code> is not a member of the my_group anymore, the Policy service denies incoming request related to viewing the <code>my-thing</code> from <code>user2@example.com</code>.</p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $USER2TOKEN\" http://localhost/things/$th\nHTTP/1.1 403 Forbidden\nServer: nginx/1.20.0\nDate: Fri, 05 Nov 2021 06:39:47 GMT\nContent-Type: application/json\nContent-Length: 60\nConnection: keep-alive\n\n{\"error\":\"failed to perform authorization over the entity\"}\n</code></pre>"},{"location":"authorization/#example-usage-of-sharing-entities-via-group","title":"Example usage of sharing entities via Group","text":"<p>Mainflux allows you to group entities (e.g., <code>Users</code> and <code>Things</code>) through <code>Group</code> object in <code>auth</code> service. You can find more details about usage of the <code>Group</code> at Groups documentation.</p> <p>In this example, we will demonstrate how you can share access of the Users group to the Things group. So, each member of the Users group will have access to each Thing assigned to the Things group. We are going to start from a clean Mainflux setup and follow these steps:</p> <ol> <li>Create a new user and multiple Things,</li> <li>Create a Thing and User group, and assign members to groups,</li> <li>Share access of the groups</li> </ol> <p>First of all, obtain a token for the default admin. You can use any user but for the simplicity of the document, the default admin will be used.</p> <p>By default, Mainflux uses credentials described in .env for the default admin.</p> <pre><code>$ curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/tokens -d '{\"email\":\"admin@example.com\",\n\"password\":\"12345678\"}'\nHTTP/1.1 201 Created\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 08:26:45 GMT\nContent-Type: application/json\nContent-Length: 285\nConnection: keep-alive\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n\n{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQxNDk2MDUsImlhdCI6MTYzNDExMzYwNSwiaXNzIjoibWFpbmZsdXguYXV0aCIsInN1YiI6ImFkbWluQGV4YW1wbGUuY29tIiwiaXNzdWVyX2lkIjoiOTA3MjkzMDMtZDMwZC00YmQ5LTkwMTYtNDljMThjZmY4YjUxIiwidHlwZSI6MH0.G1kjXiGX76BqpytmLdXtjLF9s9K5CVm4ScNMIaKlkwE\"}\n</code></pre> <p>You can store the generated token because we will need it in further steps.</p> <pre><code>$ export token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQxNDk2MDUsImlhdCI6MTYzNDExMzYwNSwiaXNzIjoibWFpbmZsdXguYXV0aCIsInN1YiI6ImFkbWluQGV4YW1wbGUuY29tIiwiaXNzdWVyX2lkIjoiOTA3MjkzMDMtZDMwZC00YmQ5LTkwMTYtNDljMThjZmY4YjUxIiwidHlwZSI6MH0.G1kjXiGX76BqpytmLdXtjLF9s9K5CVm4ScNMIaKlkwE\n</code></pre> <p>Now, we can create a new user as follows:</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" http://localhost/users -d '{\"email\":\"user@example.com\", \"password\":\"12345678\"}'\n\nHTTP/1.1 201 Created\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 08:45:57 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /users/f31f8a0a-11b1-4aa6-a4a3-9629378c0326\nStrict-Transport-Security: max-age=63072000; includeSubdomains\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: *\nAccess-Control-Allow-Headers: *\n</code></pre> <p>You can obtain the user ID via <code>Location</code>. The ID of the <code>user@example.com</code> is <code>f31f8a0a-11b1-4aa6-a4a3-9629378c0326</code>.</p> <p>After creating the new user, we have two users on the system as <code>admin@example.com</code> and <code>user@example.com</code>. Then, the admin creates multiple Things called <code>admin-thing-1</code> and <code>admin-thing-2</code>.</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $TOKEN\" http://localhost/things/bulk -d '[{\"name\": \"a\ndmin-thing-1\"}, {\"name\": \"admin-thing-2\"}]'\n\nHTTP/1.1 201 Created\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 08:53:38 GMT\nContent-Type: application/json\nContent-Length: 241\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"things\":[{\"id\":\"c3d75452-ae00-4aea-84f9-29ab79fd0d26\",\"name\":\"admin-thing-1\",\"key\":\"4fb36389-f7a5-424d-8c4f-da5c9e91f3c5\"},{\"id\":\"ee589c61-0b98-4176-9da0-d91913087be6\",\"name\":\"admin-thing-2\",\"key\":\"410f5889-c756-470d-bd65-2e99b4ecc679\"}]}\n</code></pre> <pre><code>export th1=c3d75452-ae00-4aea-84f9-29ab79fd0d26\nexport th2=ee589c61-0b98-4176-9da0-d91913087be6\n</code></pre> <p>Mainflux identifies <code>admin@example.com</code> via the token provided through the <code>Authorization</code> request header. On top of that, Mainflux claims ownership of things (<code>admin-thing-1</code> and <code>admin-thing-2</code>) on the <code>admin@example.com</code>. So that, the creator of Things (in this case <code>admin@example.com</code>) is going to have <code>read</code>, <code>write</code> and <code>delete</code> policies on the Thing.</p> <p>If <code>user@example.com</code> logs in the system, <code>user@example.com</code> cannot access the things created by the <code>admin@example.com</code> due to lack of policies.</p> <p>The next step is creating the user and things Groups respectively. You can create groups as follows:</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $TOKEN\" http://localhost/groups -d '{\"name\": \"user_group\"}'\nHTTP/1.1 201 Created\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 09:24:39 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /groups/01FHWFFMME9N2N26DG0DMNRWRW\nAccess-Control-Expose-Headers: Location\n</code></pre> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $TOKEN\" http://localhost/groups -d '{\"name\": \"thing_group\"}'\nHTTP/1.1 201 Created\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 09:24:58 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /groups/01FHWFG78DSYA458D8ST4YQ9Y9\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>Again, you can obtain group IDs via <code>Location</code> in response. It is convenient to store them in variables.</p> <pre><code>export ug=01FHWFFMME9N2N26DG0DMNRWRW\nexport tg=01FHWFG78DSYA458D8ST4YQ9Y9\n</code></pre> <p>After creating groups, we are ready to assign new members to groups. Let's start with the user group.</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $TOKEN\" http://localhost/groups/$ug/members -d '{\"members\":[\"f31f8a0a-11b1-4aa6-a4a3-9629378c0326\"], \"type\":\"users\"}'\n\nHTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 09:37:05 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>If you remember, <code>f31f8a0a-11b1-4aa6-a4a3-9629378c0326</code> is the ID of the <code>user@example.com</code>. Since the <code>$ug</code> represents the ID of the user group called <code>user_group</code>, we indicated the type of the group as <code>\"users\"</code> in the request body.</p> <p>Now, we can assign Things to the thing group.</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $TOKEN\" http://localhost/groups/$tg/members -d '{\"members\":[\"c3d75452-ae00-4aea-84f9-29ab79fd0d26\", \"ee589c61-0b98-4176-9da0-d91913087be6\"], \"type\":\"things\"}'\n\nHTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 09:42:12 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>The same logic applies here as well. The IDs of the things that <code>admin@example.com</code> created are <code>c3d75452-ae00-4aea-84f9-29ab79fd0d26</code> and <code>ee589c61-0b98-4176-9da0-d91913087be6</code>. Since the <code>$tg</code> represents the ID of the thing group called <code>thing_group</code>, we indicated the type of the group as <code>\"things\"</code> in the request body.</p> <p>Before moving to the third step, let's analyze the current situation. We have two groups, two users, and two things. The first group is the user group and consists of two users, <code>admin@example.com</code> (since the admin created the group) and <code>user@example.com</code>. The second group is the thing group. It includes two things created by <code>admin@example.com</code>.  <code>user@example.com</code> still has no access to things created by <code>admin@example.com</code>. You can verify it as:</p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $TOKEN\" http://localhost/things/$th1\nHTTP/1.1 403 Forbidden\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 09:51:45 GMT\nContent-Type: application/json\nContent-Length: 60\nConnection: keep-alive\n\n{\"error\":\"failed to perform authorization over the entity\"}\n</code></pre> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $TOKEN\" http://localhost/things/$th2\nHTTP/1.1 403 Forbidden\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 09:51:49 GMT\nContent-Type: application/json\nContent-Length: 60\nConnection: keep-alive\n\n{\"error\":\"failed to perform authorization over the entity\"}\n</code></pre> <p>The <code>$TOKEN</code> is the token for <code>user@example.com</code>. As you can see, requests to access things are denied.</p> <p>Now, let's assign group access rights.</p> <pre><code>curl -s -S -i -X POST http://localhost/groups/$ug/share -d '{\"thing_group_id\": \"01FHWFG78DSYA458D8ST4YQ9Y9\"}' -H 'Content-Type: application/json' -H \"Authorization: Bearer $TOKEN\"\nHTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 09:59:13 GMT\nContent-Type: application/json\nContent-Length: 3\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>Now, all the members of the <code>user_group</code> have access to things within the <code>thing_group</code>. Therefore, <code>user@example.com</code> has <code>read</code>, <code>write</code> and <code>delete</code> policies on the things within the thing_group.</p> <p>Try to access things as <code>user@example.com</code>.</p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $TOKEN\" http://localhost/things/$th1\nHTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 10:02:19 GMT\nContent-Type: application/json\nContent-Length: 114\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"c3d75452-ae00-4aea-84f9-29ab79fd0d26\",\"name\":\"admin-thing-1\",\"key\":\"4fb36389-f7a5-424d-8c4f-da5c9e91f3c5\"}\n</code></pre> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $TOKEN\" http://localhost/things/$th2\nHTTP/1.1 200 OK\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 10:02:21 GMT\nContent-Type: application/json\nContent-Length: 114\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n\n{\"id\":\"ee589c61-0b98-4176-9da0-d91913087be6\",\"name\":\"admin-thing-2\",\"key\":\"410f5889-c756-470d-bd65-2e99b4ecc679\"}\n</code></pre> <p>Successful!</p> <p>Let's assume, <code>admin@example.com</code> does not want to share things with <code>user@example.com</code> anymore. In order to achieve that, <code>admin@example.com</code> unassigns <code>user@example.com</code> from the <code>user_group</code>.</p> <pre><code>curl -s -S -i -X DELETE -H \"Content-Type: application/json\" -H \"Authorization: Bearer $TOKEN\" http://localhost/groups/$ug/members -d '{\"members\":[\"f31f8a0a-11b1-4aa6-a4a3-9629378c0326\"], \"type\":\"users\"}'\n\nHTTP/1.1 204 No Content\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 10:08:56 GMT\nContent-Type: application/json\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>Now, when <code>user@example.com</code> tries to access the things, the request will be denied.</p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $TOKEN\" http://localhost/things/$th1\nHTTP/1.1 403 Forbidden\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 10:10:26 GMT\nContent-Type: application/json\nContent-Length: 60\nConnection: keep-alive\n\n{\"error\":\"failed to perform authorization over the entity\"}\n</code></pre> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer $TOKEN\" http://localhost/things/$th2\nHTTP/1.1 403 Forbidden\nServer: nginx/1.20.0\nDate: Wed, 13 Oct 2021 10:10:28 GMT\nContent-Type: application/json\nContent-Length: 60\nConnection: keep-alive\n\n{\"error\":\"failed to perform authorization over the entity\"}\n</code></pre>"},{"location":"benchmark/","title":"Test spec","text":""},{"location":"benchmark/#tools","title":"Tools","text":"<ul> <li>MZBench</li> <li>vmq_mzbench</li> <li>mzb_api_ec2_plugin</li> </ul>"},{"location":"benchmark/#setting-up-mzbench","title":"Setting up MZBench","text":"<p>MZbench is open-source tool for that can generate large traffic and measure performance of the application. MZBench is distributed, cloud-aware benchmarking tool that can seamlessly scale to millions of requests. It's originally developed by satori-com but we will use mzbench fork because it can run with newest Erlang releases and the original MzBench repository is not maintained anymore.</p> <p>We will describe installing MZBench server on Ubuntu 18.04 (this can be on your PC or some external cloud server, like droplet on Digital Ocean)</p> <p>Install latest OTP/Erlang (it's version 22.3 for me)</p> <pre><code>sudo apt update\nsudo apt install erlang\n</code></pre> <p>For running this tool you will also need libz-dev package:</p> <pre><code>sudo apt-get update\nsudo apt-get install libz-dev\n</code></pre> <p>and pip:</p> <pre><code>sudo apt install python-pip\n</code></pre> <p>Clone mzbench tool and install the requirements:</p> <pre><code>git clone https://github.com/mzbench/mzbench\ncd mzbench\nsudo pip install -r requirements.txt\n</code></pre> <p>This should be enough for installing MZBench, and you can now start MZBench server with this CLI command:</p> <pre><code>./bin/mzbench start_server\n</code></pre> <p>The MZBench CLI lets you control the server and benchmarks from the command line.</p> <p>Another way of using MZBench is over Dashboard. After starting server you should check dashboard on <code>http://localhost:4800</code>. </p> <p>Note that if you are installing MZBench on external server (i.e. Digital Ocean droplet), that you'll be able to reach MZBench dashboard on your server's IP address:4800, if you previously: - change default value for <code>network_interface</code> from <code>127.0.0.1</code> to <code>0.0.0.0</code> in configuration file. Default configuration file location is <code>~/.config/mzbench/server.config</code>, create it from sample configuration file <code>~/.config/mzbench/server.config.example</code> - open port <code>4800</code> with <code>ufw allow 4800</code></p> <p>MZBench can run your test scenarios on many nodes, simultaneously. For now, you are able to run tests locally, so your nodes will be virtual nodes on machine where MZBench server is installed (your PC or DO droplet). You can try one of our MQTT scenarios that uses vmq_mzbench worker. Copy-paste scenario in MZBench dashboard, click button Environmental variables -&gt; Add from script and add appropriate values. Because it's running locally, you should try with smaller values, for example for fan-in scenario use 100 publishers on 2 nodes. Try this before moving forward in setting up Amazon EC2 plugin.</p>"},{"location":"benchmark/#setting-up-amazon-ec2-plugin","title":"Setting up Amazon EC2 plugin","text":"<p>For larger-scale tests we will set up MZBench to run each node as one of Amazon EC2 instance with built-in plugin mzb_api_ec2_plugin.</p> <p>This is basic architecture when running MZBench:</p> <p></p> <p>Every node that runs your scenarios will be one of Amazon EC2 instance; plus one more additional node \u2014 the director node. The director doesn't run scenarios, it collects the metrics from the other nodes and runs post and pre hooks. So, if you want to run jobs on 10 nodes, actually 11 EC2 instances will be created. All instances will be automatically terminated when the test finishes.</p> <p>We will use one of ready-to-use Amazon Machine Images (AMI) with all necessary dependencies. We will choose AMI with OTP 22, because that is the version we have on MZBench server. So, we will search for <code>MZBench-erl22</code> AMI and find one with id <code>ami-03a169923be706764</code> available in <code>us-west-1b</code> zone. If you have chosen this AMI, everything you do from now must be in us-west-1 zone. We must have IAM user with <code>AmazonEC2FullAccess</code> and <code>IAMFullAccess</code> permissions policies, and his <code>access_key_id</code> and <code>secret_access_key</code> goes to configuration file. In EC2 dashboard, you must create new security group <code>MZbench_cluster</code> where you will add inbound rules to open ssh and TCP ports 4801-4804. Also, in EC2 dashboard go to section <code>key pairs</code>, click <code>Actions</code> -&gt; <code>Import key pair</code> and upload public key you have on your MZBench server in <code>~/.ssh/id_rsa.pub</code> (if you need to create new, run <code>ssh-keygen</code> and follow instructions). Give it a name on EC2 dashboard, put that name (<code>key_name</code>) and path (<code>keyfile</code>) in configuration file.</p> <pre><code>[\n{mzbench_api, [\n{network_interface,\"0.0.0.0\"},\n{keyfile, \"~/.ssh/id_rsa\"},\n{cloud_plugins, [\n                  {local,#{module =&gt; mzb_dummycloud_plugin}},\n                  {ec2, #{module =&gt; mzb_api_ec2_plugin,\n                        instance_spec =&gt; [\n                          {image_id, \"ami-03a169923be706764\"},\n                          {group_set, [\"MZbench_cluster\"]},\n                          {instance_type, \"t2.micro\"},\n                          {availability_zone, \"us-west-1b\"},\n                          {iam_instance_profile_name, \"mzbench\"},\n                          {key_name, \"key_pair_name\"}\n                        ],\n                        config =&gt; [\n                          {ec2_host, \"ec2.us-west-1.amazonaws.com\"},\n                          {access_key_id, \"IAM_USER_ACCESS_KEY_ID\"},\n                          {secret_access_key, \"IAM_USER_SECRET_ACCESS_KEY\"}\n                        ],\n                        instance_user =&gt; \"ec2-user\"\n                  }}              \n              ]\n}\n]}].\n</code></pre> <p>There is both <code>local</code> and <code>ec2</code> plugin in this configuration file, so you can choose to run tests on either of them. Default path for configuration file is <code>~/.config/mzbench/server.config</code>, if it's somewhere else, server is starting with: <code>$ ./bin/mzbench start_server --config &lt;config_file&gt;</code> Note that every time you update the configuration you have to restart the server: <code>$ ./bin/mzbench restart_server</code></p>"},{"location":"benchmark/#test-scenarios","title":"Test scenarios","text":"<p>Testing environment to be determined.</p>"},{"location":"benchmark/#message-publishing","title":"Message publishing","text":"<p>In this scenario, large number of requests are sent to HTTP adapter service every second. This test checks how much time HTTP adapter needs to respond to each request.</p>"},{"location":"benchmark/#results","title":"Results","text":"<p>TBD</p>"},{"location":"benchmark/#create-and-get-client","title":"Create and get client","text":"<p>In this scenario, large number of requests are sent to things service to create things and than to retrieve their data. This test checks how much time things service needs to respond to each request.</p>"},{"location":"benchmark/#results_1","title":"Results","text":"<p>TBD</p>"},{"location":"bootstrap/","title":"Bootstrap","text":""},{"location":"bootstrap/#bootstrap","title":"Bootstrap","text":"<p><code>Bootstrapping</code> refers to a self-starting process that is supposed to proceed without external input. Mainflux platform supports bootstrapping process, but some of the preconditions need to be fulfilled in advance. The device can trigger a bootstrap when:s</p> <ul> <li>device contains only bootstrap credentials and no Mainflux credentials</li> <li>device, for any reason, fails to start a communication with the configured Mainflux services (server not responding, authentication failure, etc..).</li> <li>device, for any reason, wants to update its configuration</li> </ul> <p>Bootstrapping and provisioning are two different procedures. Provisioning refers to entities management while bootstrapping is related to entity configuration.</p> <p>Bootstrapping procedure is the following:</p> <p> 1) Configure device with Bootstrap service URL, an external key and external ID</p> <p> Optionally create Mainflux channels if they don't exist</p> <p> Optionally create Mainflux thing if it doesn't exist</p> <p> 2) Upload configuration for the Mainflux thing</p> <p> 3) Bootstrap - send a request for the configuration</p> <p> 4) Connect/disconnect thing from channels, update or remove configuration</p>"},{"location":"bootstrap/#configuration","title":"Configuration","text":"<p>The configuration of Mainflux thing consists of three major parts:</p> <ul> <li>The list of Mainflux channels the thing is connected to</li> <li>Custom configuration related to the specific thing</li> <li>Thing key and certificate data related to that thing</li> </ul> <p>Also, the configuration contains an external ID and external key, which will be explained later. In order to enable the thing to start bootstrapping process, the user needs to upload a valid configuration for that specific thing. This can be done using the following HTTP request:</p> <pre><code>curl -s -S -i -X POST -H \"Authorization: Bearer &lt;user_token&gt;\" -H \"Content-Type: application/json\" http://localhost:9013/things/configs -d '{\n        \"external_id\":\"09:6:0:sb:sa\",\n        \"thing_id\": \"1b9b8fae-9035-4969-a240-7fe5bdc0ed28\",\n        \"external_key\":\"key\",\n        \"name\":\"some\",\n        \"channels\":[\n                \"c3642289-501d-4974-82f2-ecccc71b2d83\",\n                \"cd4ce940-9173-43e3-86f7-f788e055eb14\",\n                \"ff13ca9c-7322-4c28-a25c-4fe5c7b753fc\",\n                \"c3642289-501d-4974-82f2-ecccc71b2d82\"\n],\n        \"content\": \"config...\",\n        \"client_cert\": \"PEM cert\",\n        \"client_key\": \"PEM client cert key\",\n        \"ca_cert\": \"PEM CA cert\"\n}'\n</code></pre> <p>In this example, <code>channels</code> field represents the list of Mainflux channel IDs the thing is connected to. These channels need to be provisioned before the configuration is uploaded. Field <code>content</code> represents custom configuration. This custom configuration contains parameters that can be used to set up the thing. It can also be empty if no additional set up is needed. Field <code>name</code> is human readable name and <code>thing_id</code> is an ID of the Mainflux thing. This field is not required. If <code>thing_id</code> is empty, corresponding Mainflux thing will be created implicitly and its ID will be sent as a part of <code>Location</code> header of the response. Fields <code>client_cert</code>, <code>client_key</code> and <code>ca_cert</code> represent PEM or base64-encoded DER client certificate, client certificate key and trusted CA, respectively.</p> <p>There are two more fields: <code>external_id</code> and <code>external_key</code>. External ID represents an ID of the device that corresponds to the given thing. For example, this can be a MAC address or the serial number of the device. The external key represents the device key. This is the secret key that's safely stored on the device and it is used to authorize the thing during the bootstrapping process. Please note that external ID and external key and Mainflux ID and Mainflux key are completely different concepts. External id and key are only used to authenticate a device that corresponds to the specific Mainflux thing during the bootstrapping procedure. As Configuration optionally contains client certificate and issuing CA, it's possible that device is not able to establish TLS encrypted communication with Mainflux before bootstrapping. For that purpose, Bootstrap service exposes endpoint used for secure bootstrapping which can be used regardless of protocol (HTTP or HTTPS). Both device and Bootstrap service use a secret key to encrypt the content. Encryption is done as follows:</p> <p>1) Device uses the secret encryption key to encrypt the value of that exact external key    2) Device sends a bootstrap request using the value from 1 as an Authorization header    3) Bootstrap service fetches config by its external ID    4) Bootstrap service uses the secret encryption key to decrypt Authorization header    5) Bootstrap service compares value from 4 with the external key of the config from 3 and proceeds to 6 if they're equal    6) Bootstrap service uses the secret encryption key to encrypt the content of the bootstrap response</p> <p>Please have on mind that secret key is passed to the Bootstrap service as an environment variable. As security measurement, Bootstrap service removes this variable once it reads it on startup. However, depending on your deployment, this variable can still be visible as a part of your configuration or terminal emulator environment.</p> <p>For more details on which encryption mechanisms are used, please take a look at the implementation.</p>"},{"location":"bootstrap/#bootstrapping","title":"Bootstrapping","text":"<p>Currently, the bootstrapping procedure is executed over the HTTP protocol. Bootstrapping is nothing else but fetching and applying the configuration that corresponds to the given Mainflux thing. In order to fetch the configuration, the thing needs to send a bootstrapping request:</p> <pre><code>curl -s -S -i -H \"Authorization: Thing &lt;external_key&gt;\" http://localhost:9013/things/bootstrap/&lt;external_id&gt;\n</code></pre> <p>The response body should look something like:</p> <pre><code>{\n   \"mainflux_id\":\"7c9df5eb-d06b-4402-8c1a-df476e4394c8\",\n   \"mainflux_key\":\"86a4f870-eba4-46a0-bef9-d94db2b64392\",\n   \"mainflux_channels\":[\n      {\n         \"id\":\"ff13ca9c-7322-4c28-a25c-4fe5c7b753fc\",\n         \"name\":\"some channel\",\n         \"metadata\":{\n            \"operation\":\"someop\",\n            \"type\":\"metadata\"\n         }\n      },\n      {\n         \"id\":\"925461e6-edfb-4755-9242-8a57199b90a5\",\n         \"name\":\"channel1\",\n         \"metadata\":{\n            \"type\":\"control\"\n         }\n      }\n   ],\n   \"content\":\"config...\"\n}\n</code></pre> <p>The response consists of an ID and key of the Mainflux thing, the list of channels and custom configuration (<code>content</code> field). The list of channels contains not just channel IDs, but the additional Mainflux channel data (<code>name</code> and <code>metadata</code> fields), as well.</p>"},{"location":"bootstrap/#enabling-and-disabling-things","title":"Enabling and disabling things","text":"<p>Uploading configuration does not automatically connect thing to the given list of channels. In order to connect the thing to the channels, user needs to send the following HTTP request:</p> <pre><code>curl -s -S -i -X PUT -H \"Authorization: Bearer &lt;user_token&gt;\" -H \"Content-Type: application/json\" http://localhost:9013/things/state/&lt;thing_id&gt; -d '{\"state\": 1}'\n</code></pre> <p>In order to disconnect, the same request should be sent with the value of <code>state</code> set to 0.</p> <p>For more information about the Bootstrap service API, please check out the API documentation.</p>"},{"location":"cli/","title":"CLI","text":"<p>Mainflux CLI makes it easy to manage users, things, channels and messages.</p> <p>CLI can be downloaded as separate asset from project realeses or it can be built with <code>GNU Make</code> tool:</p> <p>Get the mainflux code</p> <pre><code>go get github.com/mainflux/mainflux\n</code></pre> <p>Build the mainflux-cli</p> <pre><code>make cli\n</code></pre> <p>which will build <code>mainflux-cli</code> in <code>&lt;project_root&gt;/build</code> folder.</p> <p>Executing <code>build/mainflux-cli</code> without any arguments will output help with all available commands and flags:</p> <pre><code>Usage:\n  mainflux-cli [command]\n\nAvailable Commands:\n  bootstrap   Bootstrap management\n  certs       Certificates management\n  channels    Channels management\n  completion  Generate the autocompletion script for the specified shell\n  groups      Groups management\n  health      Health Check\n  help        Help about any command\n  keys        Keys management\n  messages    Send or read messages\n  provision   Provision things and channels from a config file\n  things      Things management\n  users       Users management\n\nFlags:\n  -a, --auth-url string        Auth service URL (default \"http://localhost\")\n  -b, --bootstrap-url string   Bootstrap service URL (default \"http://localhost\")\n  -s, --certs-url string       Certs service URL (default \"http://localhost\")\n  -c, --config string          Config path\n  -y, --content-type string    Message content type (default \"application/senml+json\")\n  -e, --email string           User email query parameter\n  -h, --help                   help for mainflux-cli\n  -p, --http-url string        HTTP adapter URL (default \"http://localhost/http\")\n  -i, --insecure               Do not check for TLS cert\n  -l, --limit uint             Limit query parameter (default 100)\n  -m, --metadata string        Metadata query parameter\n  -n, --name string            Name query parameter\n  -o, --offset uint            Offset query parameter\n  -r, --raw                    Enables raw output mode for easier parsing of output\n  -S, --status string          User status query parameter\n  -t, --things-url string      Things service URL (default \"http://localhost\")\n  -u, --users-url string       Users service URL (default \"http://localhost\")\n\nUse \"mainflux-cli [command] --help\" for more information about a command.\n</code></pre> <p>It is also possible to use the docker image <code>mainflux/cli</code> to execute CLI command:</p> <pre><code>docker run -it --rm mainflux/cli -m http://&lt;IP_SERVER&gt; [command]\n</code></pre> <p>You can execute each command with <code>-h</code> flag for more information about that command, e.g.</p> <pre><code>mainflux-cli channels -h\n</code></pre> <p>will get you usage info:</p> <pre><code>Channels management: create, get, update or delete Channel and get list of Things connected or not connected to a Channel\n\nUsage:\n  mainflux-cli channels [command]\n\nAvailable Commands:\n  connections   Connections list\n  create        Create channel\n  delete        Delete channel\n  get           Get channel\n  not-connected Not-connected list\n  update        Update channel\n\nFlags:\n  -h, --help   help for channels\n\nGlobal Flags:\n  -a, --auth-url string        Auth service URL (default \"http://localhost\")\n  -b, --bootstrap-url string   Bootstrap service URL (default \"http://localhost\")\n  -s, --certs-url string       Certs service URL (default \"http://localhost\")\n  -c, --config string          Config path\n  -y, --content-type string    Message content type (default \"application/senml+json\")\n  -e, --email string           User email query parameter\n  -h, --help                   help for mainflux-cli\n  -p, --http-url string        HTTP adapter URL (default \"http://localhost/http\")\n  -i, --insecure               Do not check for TLS cert\n  -l, --limit uint             Limit query parameter (default 100)\n  -m, --metadata string        Metadata query parameter\n  -n, --name string            Name query parameter\n  -o, --offset uint            Offset query parameter\n  -r, --raw                    Enables raw output mode for easier parsing of output\n  -S, --status string          User status query parameter\n  -t, --things-url string      Things service URL (default \"http://localhost\")\n  -u, --users-url string       Users service URL (default \"http://localhost\")\n\nUse \"mainflux-cli channels [command] --help\" for more information about a command.\n</code></pre>"},{"location":"cli/#service","title":"Service","text":""},{"location":"cli/#get-mainflux-things-services-health-check","title":"Get Mainflux Things services health check","text":"<pre><code>mainflux-cli health\n</code></pre>"},{"location":"cli/#users-management","title":"Users management","text":""},{"location":"cli/#create-user","title":"Create User","text":"<p>Mainflux has two options for user creation. Either everybody or just the admin is able to create new users. This option is dictated through policies and be configured through environment variable (<code>MF_USERS_ALLOW_SELF_REGISTER</code>). If only the admin is allowed to create new users, then the <code>&lt;user_token&gt;</code> is required because the token is used to verify that the requester is admin or not. Otherwise, the token is not used, since everybody can create new users. However, the token is still required, in order to be consistent. For more details, please see Authorization page.</p> <pre><code>if env `MF_USERS_ALLOW_SELF_REGISTER` is \"true\" then   \n  mainflux-cli users create &lt;user_email&gt; &lt;user_password&gt;\nelse   \n  mainflux-cli users create &lt;user_email&gt; &lt;user_password&gt; &lt;admin_token&gt;\n</code></pre> <p><code>MF_USERS_ALLOW_SELF_REGISTER</code> is <code>true</code> by default. Therefore, you do not need to provide <code>&lt;admin_token&gt;</code> if <code>MF_USERS_ALLOW_SELF_REGISTER</code> is true. On the other hand, if you set <code>MF_USERS_ALLOW_SELF_REGISTER</code> to <code>false</code>, the Admin token is required for authorization. Therefore, you have to provide the admin token through third argument stated as <code>&lt;admin_token&gt;</code>.</p>"},{"location":"cli/#login-user","title":"Login User","text":"<pre><code>mainflux-cli users token &lt;user_email&gt; &lt;user_password&gt;\n</code></pre>"},{"location":"cli/#get-user","title":"Get User","text":"<pre><code>mainflux-cli users get &lt;user_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-users","title":"Get Users","text":"<pre><code>mainflux-cli users get all &lt;admin_token&gt;\n</code></pre>"},{"location":"cli/#update-user-metadata","title":"Update User Metadata","text":"<pre><code>mainflux-cli users update '{\"key1\":\"value1\", \"key2\":\"value2\"}' &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#update-user-password","title":"Update User Password","text":"<pre><code>mainflux-cli users password &lt;old_password&gt; &lt;password&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#enable-user","title":"Enable User","text":"<pre><code>mainflux-cli users enable &lt;user_id&gt; &lt;admin_token&gt;\n</code></pre>"},{"location":"cli/#disable-user","title":"Disable User","text":"<pre><code>mainflux-cli users disable &lt;user_id&gt; &lt;admin_token&gt;\n</code></pre>"},{"location":"cli/#system-provisioning","title":"System Provisioning","text":""},{"location":"cli/#create-thing","title":"Create Thing","text":"<pre><code>mainflux-cli things create '{\"name\":\"myThing\"}' &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#create-thing-with-metadata","title":"Create Thing with metadata","text":"<pre><code>mainflux-cli things create '{\"name\":\"myThing\", \"metadata\": {\\\"key1\\\":\\\"value1\\\"}}' &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#bulk-provision-things","title":"Bulk Provision Things","text":"<pre><code>mainflux-cli provision things &lt;file&gt; &lt;user_token&gt;\n</code></pre> <ul> <li><code>file</code> - A CSV or JSON file containing things (must have extension <code>.csv</code> or <code>.json</code>)</li> <li><code>user_token</code> - A valid user auth token for the current system</li> </ul>"},{"location":"cli/#update-thing","title":"Update Thing","text":"<pre><code>mainflux-cli things update '{\"id\":\"&lt;thing_id&gt;\", \"name\":\"myNewName\"}' &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#identify-thing","title":"Identify Thing","text":"<pre><code>mainflux-cli things identify &lt;thing_key&gt;\n</code></pre>"},{"location":"cli/#remove-thing","title":"Remove Thing","text":"<pre><code>mainflux-cli things delete &lt;thing_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-thing","title":"Get Thing","text":"<pre><code>mainflux-cli things get &lt;thing_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-things","title":"Get Things","text":"<pre><code>mainflux-cli things get all &lt;admin_token&gt;\n</code></pre>"},{"location":"cli/#get-a-subset-list-of-provisioned-things","title":"Get a subset list of provisioned Things","text":"<pre><code>mainflux-cli things get all --offset=1 --limit=5 &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#create-channel","title":"Create Channel","text":"<pre><code>mainflux-cli channels create '{\"name\":\"myChannel\"}' &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#bulk-provision-channels","title":"Bulk Provision Channels","text":"<pre><code>mainflux-cli provision channels &lt;file&gt; &lt;user_token&gt;\n</code></pre> <ul> <li><code>file</code> - A CSV or JSON file containing channels (must have extension <code>.csv</code> or <code>.json</code>)</li> <li><code>user_token</code> - A valid user auth token for the current system</li> </ul>"},{"location":"cli/#update-channel","title":"Update Channel","text":"<pre><code>mainflux-cli channels update '{\"id\":\"&lt;channel_id&gt;\",\"name\":\"myNewName\"}' &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#remove-channel","title":"Remove Channel","text":"<pre><code>mainflux-cli channels delete &lt;channel_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-channel","title":"Get Channel","text":"<pre><code>mainflux-cli channels get &lt;channel_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-channels","title":"Get Channels","text":"<pre><code>mainflux-cli channels get all &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-a-subset-list-of-provisioned-channels","title":"Get a subset list of provisioned Channels","text":"<pre><code>mainflux-cli channels get all --offset=1 --limit=5 &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#access-control","title":"Access control","text":""},{"location":"cli/#connect-thing-to-channel","title":"Connect Thing to Channel","text":"<pre><code>mainflux-cli things connect &lt;thing_id&gt; &lt;channel_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#bulk-connect-things-to-channels","title":"Bulk Connect Things to Channels","text":"<pre><code>mainflux-cli provision connect &lt;file&gt; &lt;user_token&gt;\n</code></pre> <ul> <li><code>file</code> - A CSV or JSON file containing thing and channel ids (must have extension <code>.csv</code> or <code>.json</code>)</li> <li><code>user_token</code> - A valid user auth token for the current system</li> </ul> <p>An example CSV file might be</p> <pre><code>&lt;thing_id&gt;,&lt;channel_id&gt;\n&lt;thing_id&gt;,&lt;channel_id&gt;\n</code></pre> <p>in which the first column is thing IDs and the second column is channel IDs.  A connection will be created for each thing to each channel.  This example would result in 4 connections being created.</p> <p>A comparable JSON file would be</p> <pre><code>{\n    \"thing_ids\": [\n        \"&lt;thing_id&gt;\",\n        \"&lt;thing_id&gt;\"\n    ],\n    \"channel_ids\": [\n        \"&lt;channel_id&gt;\",\n        \"&lt;channel_id&gt;\"\n    ]\n}\n</code></pre>"},{"location":"cli/#disconnect-thing-from-channel","title":"Disconnect Thing from Channel","text":"<pre><code>mainflux-cli things disconnect &lt;thing_id&gt; &lt;channel_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-a-subset-list-of-channels-connected-to-thing","title":"Get a subset list of Channels connected to Thing","text":"<pre><code>mainflux-cli things connections &lt;thing_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-a-subset-list-of-things-connected-to-channel","title":"Get a subset list of Things connected to Channel","text":"<pre><code>mainflux-cli channels connections &lt;channel_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#messaging","title":"Messaging","text":""},{"location":"cli/#send-a-message-over-http","title":"Send a message over HTTP","text":"<pre><code>mainflux-cli messages send &lt;channel_id&gt; '[{\"bn\":\"Dev1\",\"n\":\"temp\",\"v\":20}, {\"n\":\"hum\",\"v\":40}, {\"bn\":\"Dev2\", \"n\":\"temp\",\"v\":20}, {\"n\":\"hum\",\"v\":40}]' &lt;thing_auth_token&gt;\n</code></pre>"},{"location":"cli/#read-messages-over-http","title":"Read messages over HTTP","text":"<pre><code>mainflux-cli messages read &lt;channel_id&gt; &lt;user_token&gt; -R &lt;reader_url&gt;\n</code></pre>"},{"location":"cli/#bootstrap","title":"Bootstrap","text":""},{"location":"cli/#add-configuration","title":"Add configuration","text":"<pre><code>mainflux-cli bootstrap create '{\"external_id\": \"myExtID\", \"external_key\": \"myExtKey\", \"name\": \"myName\", \"content\": \"myContent\"}' &lt;user_token&gt; -b &lt;bootstrap-url&gt;\n</code></pre>"},{"location":"cli/#view-configuration","title":"View configuration","text":"<pre><code>mainflux-cli bootstrap view &lt;thing_id&gt; &lt;user_token&gt; -b &lt;bootstrap-url&gt;\n</code></pre>"},{"location":"cli/#update-configuration","title":"Update configuration","text":"<pre><code>mainflux-cli bootstrap update '{\"mainflux_id\":\"&lt;thing_id&gt;\", \"name\": \"newName\", \"content\": \"newContent\"}' &lt;user_token&gt; -b &lt;bootstrap-url&gt;\n</code></pre>"},{"location":"cli/#remove-configuration","title":"Remove configuration","text":"<pre><code>mainflux-cli bootstrap remove &lt;thing_id&gt; &lt;user_token&gt; -b &lt;bootstrap-url&gt;\n</code></pre>"},{"location":"cli/#bootstrap-configuration","title":"Bootstrap configuration","text":"<pre><code>mainflux-cli bootstrap bootstrap &lt;external_id&gt; &lt;external_key&gt; -b &lt;bootstrap-url&gt;\n</code></pre>"},{"location":"cli/#key","title":"Key","text":""},{"location":"cli/#issue-key","title":"Issue Key","text":"<pre><code>mainflux-cli keys issue &lt;duration&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#retrieve-key","title":"Retrieve Key","text":"<pre><code>mainflux-cli keys retrieve &lt;key_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#revoke-key","title":"Revoke Key","text":"<pre><code>mainflux-cli keys revoke &lt;key_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#groups","title":"Groups","text":""},{"location":"cli/#create-group","title":"Create Group","text":"<pre><code>mainflux-cli groups create '{\"Name\":\"&lt;group_name&gt;\",\"Description\":\"&lt;description&gt;\",\"ParentID\":\"&lt;parent_id&gt;\",\"Metadata\":\"&lt;metadata&gt;\"}' &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-group","title":"Get Group","text":"<pre><code>mainflux-cli groups get &lt;group_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#get-groups","title":"Get Groups","text":"<pre><code>mainflux-cli groups get all &lt;admin_token&gt;\n</code></pre>"},{"location":"cli/#get-group-members","title":"Get Group Members","text":"<pre><code>mainflux-cli groups members &lt;group_id&gt; &lt;admin_token&gt;\n</code></pre>"},{"location":"cli/#get-memberships","title":"Get Memberships","text":"<pre><code>mainflux-cli groups membership &lt;member_id&gt; &lt;admin_token&gt;\n</code></pre>"},{"location":"cli/#assign-members-to-group","title":"Assign Members to Group","text":"<pre><code>mainflux-cli groups assign &lt;member_ids&gt; &lt;member_type&gt; &lt;group_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#unassign-members-to-group","title":"Unassign Members to Group","text":"<pre><code>mainflux-cli groups unassign &lt;member_ids&gt; &lt;group_id&gt;  &lt;user_token&gt;\n</code></pre>"},{"location":"cli/#delete-group","title":"Delete Group","text":"<pre><code>mainflux-cli groups delete &lt;group_id&gt; &lt;user_token&gt;\n</code></pre>"},{"location":"dev-guide/","title":"Developer's guide","text":""},{"location":"dev-guide/#getting-mainflux","title":"Getting Mainflux","text":"<p>Mainflux source can be found in the official Mainflux GitHub repository. You should fork this repository in order to make changes to the project. The forked version of the repository should be cloned using the following:</p> <pre><code>git clone &lt;forked repository&gt; $SOMEPATH/mainflux\ncd $SOMEPATH/mainflux\n</code></pre> <p>Note: If your <code>$SOMEPATH</code> is equal to <code>$GOPATH/src/github.com/mainflux/mainflux</code>, make sure that your <code>$GOROOT</code> and <code>$GOPATH</code> do not overlap (otherwise, go modules won't work).</p>"},{"location":"dev-guide/#building","title":"Building","text":""},{"location":"dev-guide/#prerequisites","title":"Prerequisites","text":"<p>Make sure that you have Protocol Buffers (version 3.19.1) compiler (<code>protoc</code>) installed.</p> <p>Go Protobuf installation instructions are here. Go Protobuf uses C bindings, so you will need to install C++ protobuf as a prerequisite. Mainflux uses <code>Protocol Buffers for Go with Gadgets</code> to generate faster marshaling and unmarshaling Go code. Protocol Buffers for Go with Gadgets installation instructions can be found here.</p> <p>A copy of Go (version 1.17.5) and docker template (version 3.7) will also need to be installed on your system.</p> <p>If any of these versions seem outdated, the latest can always be found in our CI script.</p>"},{"location":"dev-guide/#build-all-services","title":"Build All Services","text":"<p>Use the GNU Make tool to build all Mainflux services:</p> <pre><code>make\n</code></pre> <p>Build artifacts will be put in the <code>build</code> directory.</p> <p>N.B. All Mainflux services are built as a statically linked binaries. This way they can be portable (transferred to any platform just by placing them there and running them) as they contain all needed libraries and do not relay on shared system libraries. This helps creating FROM scratch dockers.</p>"},{"location":"dev-guide/#build-individual-microservice","title":"Build Individual Microservice","text":"<p>Individual microservices can be built with:</p> <pre><code>make &lt;microservice_name&gt;\n</code></pre> <p>For example:</p> <pre><code>make http\n</code></pre> <p>will build the HTTP Adapter microservice.</p>"},{"location":"dev-guide/#building-dockers","title":"Building Dockers","text":"<p>Dockers can be built with:</p> <pre><code>make dockers\n</code></pre> <p>or individually with:</p> <pre><code>make docker_&lt;microservice_name&gt;\n</code></pre> <p>For example:</p> <pre><code>make docker_http\n</code></pre> <p>N.B. Mainflux creates <code>FROM scratch</code> docker containers which are compact and small in size.</p> <p>N.B. The <code>things-db</code> and <code>users-db</code> containers are built from a vanilla PostgreSQL docker image downloaded from docker hub which does not persist the data when these containers are rebuilt. Thus, rebuilding of all docker containers with <code>make dockers</code> or rebuilding the <code>things-db</code> and <code>users-db</code> containers separately with <code>make docker_things-db</code> and <code>make docker_users-db</code> respectively, will cause data loss. All your users, things, channels and connections between them will be lost! As we use this setup only for development, we don't guarantee any permanent data persistence. Though, in order to enable data retention, we have configured persistent volumes for each container that stores some data. If you want to update your Mainflux dockerized installation and want to keep your data, use <code>make cleandocker</code> to clean the containers and images and keep the data (stored in docker persistent volumes) and then <code>make run</code> to update the images and the containers. Check the Cleaning up your dockerized Mainflux setup section for details. Please note that this kind of updating might not work if there are database changes.</p>"},{"location":"dev-guide/#building-docker-images-for-development","title":"Building Docker images for development","text":"<p>In order to speed up build process, you can use commands such as:</p> <pre><code>make dockers_dev\n</code></pre> <p>or individually with</p> <pre><code>make docker_dev_&lt;microservice_name&gt;\n</code></pre> <p>Commands <code>make dockers</code> and <code>make dockers_dev</code> are similar. The main difference is that building images in the development mode is done on the local machine, rather than an intermediate image, which makes building images much faster. Before running this command, corresponding binary needs to be built in order to make changes visible. This can be done using <code>make</code> or <code>make &lt;service_name&gt;</code> command. Commands <code>make dockers_dev</code> and <code>make docker_dev_&lt;service_name&gt;</code> should be used only for development to speed up the process of image building. For deployment images, commands from section above should be used.</p>"},{"location":"dev-guide/#suggested-workflow","title":"Suggested workflow","text":"<p>When the project is first cloned to your system, you will need to make sure and build all of the Mainflux services.</p> <pre><code>make\nmake dockers_dev\n</code></pre> <p>As you develop and test changes, only the services related to your changes will need to be rebuilt. This will reduce compile time and create a much more enjoyable development experience.</p> <pre><code>make &lt;microservice_name&gt;\nmake docker_dev_&lt;microservice_name&gt;\nmake run\n</code></pre>"},{"location":"dev-guide/#overriding-the-default-docker-compose-configuration","title":"Overriding the default docker-compose configuration","text":"<p>Sometimes, depending on the use case and the user's needs it might be useful to override or add some extra parameters to the docker-compose configuration. These configuration changes can be done by specifying multiple compose files with the docker-compose command line option -f as described here. The following format of the <code>docker-compose</code> command can be used to extend or override the configuration:</p> <pre><code>docker-compose -f docker/docker-compose.yml -f docker/docker-compose.custom1.yml -f docker/docker-compose.custom2.yml up [-d]\n</code></pre> <p>In the command above each successive file overrides the previous parameters.</p> <p>A practical example in our case would be to enable debugging and tracing in NATS so that we can see better how are the messages moving around.</p> <p><code>docker-compose.nats-debugging.yml</code></p> <pre><code>version: \"3\"\n\nservices:\n  nats:\n    command: --debug -DV\n</code></pre> <p>When we have the override files in place, to compose the whole infrastructure including the persistent volumes we can execute:</p> <pre><code>docker-compose -f docker/docker-compose.yml -f docker/docker-compose.nats-debugging.yml up -d\n</code></pre> <p>Note: Please store your customizations to some folder outside the Mainflux's source folder and maybe add them to some other git repository. You can always apply your customizations by pointing to the right file using <code>docker-compose -f ...</code>.</p>"},{"location":"dev-guide/#cleaning-up-your-dockerized-mainflux-setup","title":"Cleaning up your dockerized Mainflux setup","text":"<p>If you want to clean your whole dockerized Mainflux installation you can use the <code>make pv=true cleandocker</code> command. Please note that by default the <code>make cleandocker</code> command will stop and delete all of the containers and images, but NOT DELETE persistent volumes. If you want to delete the gathered data in the system (the persistent volumes) please use the following command <code>make pv=true cleandocker</code> (pv = persistent volumes). This form of the command will stop and delete the containers, the images and will also delete the persistent volumes.</p>"},{"location":"dev-guide/#mqtt-microservice","title":"MQTT Microservice","text":"<p>The MQTT Microservice in Mainflux is special, as it is currently the only microservice written in NodeJS. It is not compiled, but node modules need to be downloaded in order to start the service:</p> <pre><code>cd mqtt\nnpm install\n</code></pre> <p>Note that there is a shorthand for doing these commands with <code>make</code> tool:</p> <pre><code>make mqtt\n</code></pre> <p>After that, the MQTT Adapter can be started from top directory (as it needs to find <code>*.proto</code> files) with:</p> <pre><code>node mqtt/mqtt.js\n</code></pre>"},{"location":"dev-guide/#troubleshooting","title":"Troubleshooting","text":"<p>Depending on your use case, MQTT topics, message size, the number of clients and the frequency with which the messages are sent it can happen that you experience some problems.</p> <p>Up until now it has been noticed that in case of high load, big messages and many clients it can happen that the MQTT microservice crashes with the following error:</p> <pre><code>mainflux-mqtt   | FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory\nmainflux-mqtt exited with code 137\n</code></pre> <p>This problem is caused the default allowed memory in node (V8). V8 gives the user 1.7GB per default. To fix the problem you should add the following environment variable <code>NODE_OPTIONS:--max-old-space-size=SPACE_IN_MB</code> in the environment section of the aedes.yml configuration. To find the right value for the <code>--max-old-space-size</code> parameter you'll have to experiment a bit depending on your needs.</p> <p>The Mainflux MQTT service uses the Aedes MQTT Broker for implementation of the MQTT related things. Therefore, for some questions or problems you can also check out the Aedes's documentation or reach out its contributors.</p>"},{"location":"dev-guide/#protobuf","title":"Protobuf","text":"<p>If you've made any changes to <code>.proto</code> files, you should call <code>protoc</code> command prior to compiling individual microservices.</p> <p>To do this by hand, execute:</p> <pre><code>protoc --gofast_out=plugins=grpc:. *.proto\nprotoc --gogo_out=plugins=grpc:. broker/*.proto\n</code></pre> <p>A shorthand to do this via <code>make</code> tool is:</p> <pre><code>make proto\n</code></pre> <p>N.B. This must be done once at the beginning in order to generate protobuf Go structures needed for the build. However, if you don't change any of <code>.proto</code> files, this step is not mandatory, since all generated files are included in the repository (those are files with <code>.pb.go</code> extension).</p>"},{"location":"dev-guide/#cross-compiling-for-arm","title":"Cross-compiling for ARM","text":"<p>Mainflux can be compiled for ARM platform and run on Raspberry Pi or other similar IoT gateways, by following the instructions here or here as well as information found here. The environment variables <code>GOARCH=arm</code> and <code>GOARM=7</code> must be set for the compilation.</p> <p>Cross-compilation for ARM with Mainflux make:</p> <pre><code>GOOS=linux GOARCH=arm GOARM=7 make\n</code></pre>"},{"location":"dev-guide/#running-tests","title":"Running tests","text":"<p>To run all of the tests you can execute:</p> <pre><code>make test\n</code></pre> <p>Dockertest is used for the tests, so to run them, you will need the Docker daemon/service running.</p>"},{"location":"dev-guide/#installing","title":"Installing","text":"<p>Installing Go binaries is simple: just move them from <code>build</code> to <code>$GOBIN</code> (do not fortget to add <code>$GOBIN</code> to your <code>$PATH</code>).</p> <p>You can execute:</p> <pre><code>make install\n</code></pre> <p>which will do this copying of the binaries.</p> <p>N.B. Only Go binaries will be installed this way. The MQTT adapter is a NodeJS script and will stay in the <code>mqtt</code> dir.</p>"},{"location":"dev-guide/#deployment","title":"Deployment","text":""},{"location":"dev-guide/#prerequisites_1","title":"Prerequisites","text":"<p>Mainflux depends on several infrastructural services, notably the default message broker, NATS and PostgreSQL database.</p>"},{"location":"dev-guide/#message-broker","title":"Message Broker","text":"<p>Mainflux uses NATS as it's default central message bus. For development purposes (when not run via Docker), it expects that NATS is installed on the local system.</p> <p>To do this execute:</p> <pre><code>go get github.com/nats-io/gnatsd\n</code></pre> <p>This will install <code>gnatsd</code> binary that can be simply run by executing:</p> <pre><code>gnatsd\n</code></pre> <p>If you want to change the default message broker to RabbitMQ, VerneMQ or Kafka you need to install it on the local system.</p>"},{"location":"dev-guide/#postgresql","title":"PostgreSQL","text":"<p>Mainflux uses PostgreSQL to store metadata (<code>users</code>, <code>things</code> and <code>channels</code> entities alongside with authorization tokens). It expects that PostgreSQL DB is installed, set up and running on the local system.</p> <p>Information how to set-up (prepare) PostgreSQL database can be found here, and it is done by executing following commands:</p> <pre><code># Create `users` and `things` databases\nsudo -u postgres createdb users\nsudo -u postgres createdb things\n\n# Set-up Postgres roles\nsudo su - postgres\npsql -U postgres\npostgres=# CREATE ROLE mainflux WITH LOGIN ENCRYPTED PASSWORD 'mainflux';\npostgres=# ALTER USER mainflux WITH LOGIN ENCRYPTED PASSWORD 'mainflux';\n</code></pre>"},{"location":"dev-guide/#mainflux-services","title":"Mainflux Services","text":"<p>Running of the Mainflux microservices can be tricky, as there is a lot of them and each demand configuration in the form of environment variables.</p> <p>The whole system (set of microservices) can be run with one command:</p> <pre><code>make rundev\n</code></pre> <p>which will properly configure and run all microservices.</p> <p>Please assure that MQTT microservice has <code>node_modules</code> installed, as explained in MQTT Microservice chapter.</p> <p>N.B. <code>make rundev</code> actually calls helper script <code>scripts/run.sh</code>, so you can inspect this script for the details.</p>"},{"location":"dev-guide/#events","title":"Events","text":"<p>In order to be easily integratable system, Mainflux is using Redis Streams as an event log for event sourcing. Services that are publishing events to Redis Streams are <code>things</code> service, <code>bootstrap</code> service and <code>mqtt</code> adapter.</p>"},{"location":"dev-guide/#things-service","title":"Things Service","text":"<p>For every operation that has side effects (that is changing service state) <code>things</code> service will generate new event and publish it to Redis Stream called <code>mainflux.things</code>. Every event has its own event ID that is automatically generated and <code>operation</code> field that can have one of the following values: - <code>thing.create</code> for thing creation, - <code>thing.update</code> for thing update, - <code>thing.remove</code> for thing removal, - <code>thing.connect</code> for connecting a thing to a channel, - <code>thing.disconnect</code> for disconnecting thing from a channel, - <code>channel.create</code> for channel creation, - <code>channel.update</code> for channel update, - <code>channel.remove</code> for channel removal.</p> <p>By fetching and processing these events you can reconstruct <code>things</code> service state. If you store some of your custom data in <code>metadata</code> field, this is the perfect way to fetch it and process it. If you want to integrate through docker-compose.yml you can use <code>mainflux-es-redis</code> service. Just connect to it and consume events from Redis Stream named <code>mainflux.things</code>.</p>"},{"location":"dev-guide/#thing-create-event","title":"Thing create event","text":"<p>Whenever thing is created, <code>things</code> service will generate new <code>create</code> event. This event will have the following format:</p> <pre><code>1) \"1555334740911-0\"\n2)  1) \"operation\"\n    2) \"thing.create\"\n    3) \"name\"\n    4) \"d0\"\n    5) \"id\"\n    6) \"3c36273a-94ea-4802-84d6-a51de140112e\"\n    7) \"owner\"\n    8) \"john.doe@email.com\"\n    9) \"metadata\"\n   10) \"{}\"\n</code></pre> <p>As you can see from this example, every odd field represents field name while every even field represents field value. This is standard event format for Redis Streams. If you want to extract <code>metadata</code> field from this event, you'll have to read it as string first and then you can deserialize it to some structured format.</p>"},{"location":"dev-guide/#thing-update-event","title":"Thing update event","text":"<p>Whenever thing instance is updated, <code>things</code> service will generate new <code>update</code> event. This event will have the following format:</p> <pre><code>1) \"1555336161544-0\"\n2) 1) \"operation\"\n   2) \"thing.update\"\n   3) \"name\"\n   4) \"weio\"\n   5) \"id\"\n   6) \"3c36273a-94ea-4802-84d6-a51de140112e\"\n</code></pre> <p>Note that thing update event will contain only those fields that were updated using update endpoint.</p>"},{"location":"dev-guide/#thing-remove-event","title":"Thing remove event","text":"<p>Whenever thing instance is removed from the system, <code>things</code> service will generate and publish new <code>remove</code> event. This event will have the following format:</p> <pre><code>1) 1) \"1555339313003-0\"\n2) 1) \"id\"\n   2) \"3c36273a-94ea-4802-84d6-a51de140112e\"\n   3) \"operation\"\n   4) \"thing.remove\"\n</code></pre>"},{"location":"dev-guide/#channel-create-event","title":"Channel create event","text":"<p>Whenever channel instance is created, <code>things</code> service will generate and publish new <code>create</code> event. This event will have the following format:</p> <pre><code>1) \"1555334740918-0\"\n2) 1) \"id\"\n   2) \"16fb2748-8d3b-4783-b272-bb5f4ad4d661\"\n   3) \"owner\"\n   4) \"john.doe@email.com\"\n   5) \"operation\"\n   6) \"channel.create\"\n   7) \"name\"\n   8) \"c1\"\n</code></pre>"},{"location":"dev-guide/#channel-update-event","title":"Channel update event","text":"<p>Whenever channel instance is updated, <code>things</code> service will generate and publish new <code>update</code> event. This event will have the following format:</p> <pre><code>1) \"1555338870341-0\"\n2) 1) \"name\"\n   2) \"chan\"\n   3) \"id\"\n   4) \"d9d8f31b-f8d4-49c5-b943-6db10d8e2949\"\n   5) \"operation\"\n   6) \"channel.update\"\n</code></pre> <p>Note that update channel event will contain only those fields that were updated using update channel endpoint.</p>"},{"location":"dev-guide/#channel-remove-event","title":"Channel remove event","text":"<p>Whenever channel instance is removed from the system, <code>things</code> service will generate and publish new <code>remove</code> event. This event will have the following format:</p> <pre><code>1) 1) \"1555339429661-0\"\n2) 1) \"id\"\n   2) \"d9d8f31b-f8d4-49c5-b943-6db10d8e2949\"\n   3) \"operation\"\n   4) \"channel.remove\"\n</code></pre>"},{"location":"dev-guide/#connect-thing-to-a-channel-event","title":"Connect thing to a channel event","text":"<p>Whenever thing is connected to a channel on <code>things</code> service, <code>things</code> service will generate and publish new <code>connect</code> event. This event will have the following format:</p> <pre><code>1) \"1555334740920-0\"\n2) 1) \"chan_id\"\n   2) \"d9d8f31b-f8d4-49c5-b943-6db10d8e2949\"\n   3) \"thing_id\"\n   4) \"3c36273a-94ea-4802-84d6-a51de140112e\"\n   5) \"operation\"\n   6) \"thing.connect\"\n</code></pre>"},{"location":"dev-guide/#disconnect-thing-from-a-channel-event","title":"Disconnect thing from a channel event","text":"<p>Whenever thing is disconnected from a channel on <code>things</code> service, <code>things</code> service will generate and publish new <code>disconnect</code> event. This event will have the following format:</p> <pre><code>1) \"1555334740920-0\"\n2) 1) \"chan_id\"\n   2) \"d9d8f31b-f8d4-49c5-b943-6db10d8e2949\"\n   3) \"thing_id\"\n   4) \"3c36273a-94ea-4802-84d6-a51de140112e\"\n   5) \"operation\"\n   6) \"thing.disconnect\"\n</code></pre> <p>Note: Every one of these events will omit fields that were not used or are not relevant for specific operation. Also, field ordering is not guaranteed, so DO NOT rely on it.</p>"},{"location":"dev-guide/#bootstrap-service","title":"Bootstrap Service","text":"<p>Bootstrap service publishes events to Redis Stream called <code>mainflux.bootstrap</code>. Every event from this service contains <code>operation</code> field which indicates one of the following event types: - <code>config.create</code> for configuration creation, - <code>config.update</code> for configuration update, - <code>config.remove</code> for configuration removal, - <code>thing.bootstrap</code> for device bootstrap, - <code>thing.state_change</code> for device state change, - <code>thing.update_connections</code> for device connection update.</p> <p>If you want to integrate through docker-compose.yml you can use <code>mainflux-es-redis</code> service. Just connect to it and consume events from Redis Stream named <code>mainflux.bootstrap</code>.</p>"},{"location":"dev-guide/#configuration-create-event","title":"Configuration create event","text":"<p>Whenever configuration is created, <code>bootstrap</code> service will generate and publish new <code>create</code> event. This event will have the following format:</p> <pre><code>1) \"1555404899581-0\"\n2)  1) \"owner\"\n    2) \"john.doe@email.com\"\n    3) \"name\"\n    4) \"some\"\n    5) \"channels\"\n    6) \"ff13ca9c-7322-4c28-a25c-4fe5c7b753fc, c3642289-501d-4974-82f2-ecccc71b2d82, c3642289-501d-4974-82f2-ecccc71b2d83, cd4ce940-9173-43e3-86f7-f788e055eb14\"\n    7) \"externalID\"\n    8) \"9c:b6:d:eb:9f:fd\"\n    9) \"content\"\n   10) \"{}\"\n   11) \"timestamp\"\n   12) \"1555404899\"\n   13) \"operation\"\n   14) \"config.create\"\n   15) \"thing_id\"\n   16) \"63a110d4-2b77-48d2-aa46-2582681eeb82\"\n</code></pre>"},{"location":"dev-guide/#configuration-update-event","title":"Configuration update event","text":"<p>Whenever configuration is updated, <code>bootstrap</code> service will generate and publish new <code>update</code> event. This event will have the following format:</p> <pre><code>1) \"1555405104368-0\"\n2)  1) \"content\"\n    2) \"NOV_MGT_HOST: http://127.0.0.1:7000\\nDOCKER_MGT_HOST: http://127.0.0.1:2375\\nAGENT_MGT_HOST: https://127.0.0.1:7003\\nMF_MQTT_HOST: tcp://104.248.142.133:8443\"              \n    3) \"timestamp\"\n    4) \"1555405104\"\n    5) \"operation\"\n    6) \"config.update\"\n    7) \"thing_id\"\n    8) \"63a110d4-2b77-48d2-aa46-2582681eeb82\"\n    9) \"name\"\n   10) \"weio\"\n</code></pre>"},{"location":"dev-guide/#configuration-remove-event","title":"Configuration remove event","text":"<p>Whenever configuration is removed, <code>bootstrap</code> service will generate and publish new <code>remove</code> event. This event will have the following format:</p> <pre><code>1) \"1555405464328-0\"\n2) 1) \"thing_id\"\n   2) \"63a110d4-2b77-48d2-aa46-2582681eeb82\"\n   3) \"timestamp\"\n   4) \"1555405464\"\n   5) \"operation\"\n   6) \"config.remove\"\n</code></pre>"},{"location":"dev-guide/#thing-bootstrap-event","title":"Thing bootstrap event","text":"<p>Whenever thing is bootstrapped, <code>bootstrap</code> service will generate and publish new <code>bootstrap</code> event. This event will have the following format:</p> <pre><code>1) \"1555405173785-0\"\n2) 1) \"externalID\"\n   2) \"9c:b6:d:eb:9f:fd\"\n   3) \"success\"\n   4) \"1\"\n   5) \"timestamp\"\n   6) \"1555405173\"\n   7) \"operation\"\n   8) \"thing.bootstrap\"\n</code></pre>"},{"location":"dev-guide/#thing-change-state-event","title":"Thing change state event","text":"<p>Whenever thing's state changes, <code>bootstrap</code> service will generate and publish new <code>change state</code> event. This event will have the following format:</p> <pre><code>1) \"1555405294806-0\"\n2) 1) \"thing_id\"\n   2) \"63a110d4-2b77-48d2-aa46-2582681eeb82\"\n   3) \"state\"\n   4) \"0\"\n   5) \"timestamp\"\n   6) \"1555405294\"\n   7) \"operation\"\n   8) \"thing.state_change\"\n</code></pre>"},{"location":"dev-guide/#thing-update-connections-event","title":"Thing update connections event","text":"<p>Whenever thing's list of connections is updated, <code>bootstrap</code> service will generate and publish new <code>update connections</code> event. This event will have the following format:</p> <pre><code>1) \"1555405373360-0\"\n2) 1) \"operation\"\n   2) \"thing.update_connections\"\n   3) \"thing_id\"\n   4) \"63a110d4-2b77-48d2-aa46-2582681eeb82\"\n   5) \"channels\"\n   6) \"ff13ca9c-7322-4c28-a25c-4fe5c7b753fc, 925461e6-edfb-4755-9242-8a57199b90a5, c3642289-501d-4974-82f2-ecccc71b2d82\"\n   7) \"timestamp\"\n   8) \"1555405373\"\n</code></pre>"},{"location":"dev-guide/#mqtt-adapter","title":"MQTT Adapter","text":"<p>Instead of using heartbeat to know when client is connected through MQTT adapter one can fetch events from Redis Streams that MQTT adapter publishes. MQTT adapter publishes events every time client connects and disconnects to stream named <code>mainflux.mqtt</code>.</p> <p>Events that are coming from MQTT adapter have following fields: - <code>thing_id</code> ID of a thing that has connected to MQTT adapter, - <code>timestamp</code> is in Epoch UNIX Time Stamp format, - <code>event_type</code> can have two possible values, connect and disconnect, - <code>instance</code> represents MQTT adapter instance.</p> <p>If you want to integrate through docker-compose.yml you can use <code>mainflux-es-redis</code> service. Just connect to it and consume events from Redis Stream named <code>mainflux.mqtt</code>.</p> <p>Example of connect event:</p> <pre><code>1) 1) \"1555351214144-0\"\n2) 1) \"thing_id\"\n   2) \"1c597a85-b68e-42ff-8ed8-a3a761884bc4\"\n   3) \"timestamp\"\n   4) \"1555351214\"\n   5) \"event_type\"\n   6) \"connect\"\n   7) \"instance\"\n   8) \"mqtt-adapter-1\"\n</code></pre> <p>Example of disconnect event:</p> <pre><code>1) 1) \"1555351214188-0\"\n2) 1) \"thing_id\"\n   2) \"1c597a85-b68e-42ff-8ed8-a3a761884bc4\"\n   3) \"timestamp\"\n   4) \"1555351214\"\n   5) \"event_type\"\n   6) \"disconnect\"\n   7) \"instance\"\n   8) \"mqtt-adapter-1\"\n</code></pre>"},{"location":"edge/","title":"Edge","text":"<p>Mainflux IoT platform provides services for supporting management of devices on the edge. Typically, IoT solution includes devices (sensors/actuators) deployed in far edge and connected through some proxy gateway. Although most devices could be connected to the Mainflux directly, using gateways decentralizes system, decreases load on the cloud and makes setup less difficult. Also, gateways can provide additional data processing, filtering and storage.</p> <p>Services that can be used on gateway to enable data and control plane for edge:</p> <ul> <li>Agent</li> <li>Export</li> <li>Mainflux</li> </ul> Figure 1 - Edge services deployment <p>Figure shows edge gateway that is running Agent, Export and minimal deployment of Mainflux services. Mainflux services enable device management and MQTT protocol, NATS being a central message bus as it is the default message broker in Mainflux becomes also central message bus for other services like <code>Agent</code> and <code>Export</code> as well as for any new custom developed service that can be built to interface with devices with any of hardware supported interfaces on the gateway, those services would publish data to the message broker where <code>Export</code> service can pick them up and send to cloud.</p> <p>Agent can be used to control deployed services as well as to monitor their liveliness through subcribing to <code>heartbeat</code> Message Broker subject where services should publish their liveliness status, like <code>Export</code> service does.</p>"},{"location":"edge/#agent","title":"Agent","text":"<p>Agent is service that is used to manage gateways that are connected to Mainflux in cloud. It provides a way to send commands to gateway and receive response via mqtt. There are two types of channels used for Agent <code>data</code> and <code>control</code>. Over the <code>control</code> we are sending commands and receiving response from commands. Data collected from sensors connected to gateway are being sent over <code>data</code> channel. Agent is able to configure itself provided that bootstrap server is running, it will retrieve configuration from bootstrap server provided few arguments - <code>external_id</code> and <code>external_key</code> see bootstraping.</p> <p>Agent service has following features: * Remote execution of commands * Remote terminal, remote session to <code>bash</code> managed by <code>Agent</code> * Heartbeat - listening to  Message Broker topic <code>heartbeat.&gt;</code> it can remotely provide info on running services, if services are publishing heartbeat ( like Export) * Proxying commands to other gateway services * Edgex SMA - remotely making requests to EdgeX endpoints and fetching results, if EdgeX is deployed.</p>"},{"location":"edge/#run-agent","title":"Run Agent","text":"<p>Before running agent we need to provision a thing and DATA and CONTROL channel. Thing that will be used as gateway representation and make bootstrap configuration. If using Mainflux UI this is done automatically when adding gateway through UI. Gateway can be provisioned with <code>provision</code> service.</p> <p>When you provisioned gateway as described in provision you can check results</p> <pre><code>curl -s -S -X GET http://mainflux-domain.com:9013/things/bootstrap/&lt;external_id&gt; -H \"Authorization: Thing &lt;external_key&gt;\" -H 'Content-Type: application/json' |jq\n</code></pre> <pre><code>{\n  \"mainflux_id\": \"e22c383a-d2ab-47c1-89cd-903955da993d\",\n  \"mainflux_key\": \"fc987711-1828-461b-aa4b-16d5b2c642fe\",\n  \"mainflux_channels\": [\n    {\n      \"id\": \"fa5f9ba8-a1fc-4380-9edb-d0c23eaa24ec\",\n      \"name\": \"control-channel\",\n      \"metadata\": {\n        \"type\": \"control\"\n      }\n    },\n    {\n      \"id\": \"24e5473e-3cbe-43d9-8a8b-a725ff918c0e\",\n      \"name\": \"data-channel\",\n      \"metadata\": {\n        \"type\": \"data\"\n      }\n    },\n    {\n      \"id\": \"1eac45c2-0f72-4089-b255-ebd2e5732bbb\",\n      \"name\": \"export-channel\",\n      \"metadata\": {\n        \"type\": \"export\"\n      }\n    }\n  ],\n  \"content\": \"{\\\"agent\\\":{\\\"edgex\\\":{\\\"url\\\":\\\"http://localhost:48090/api/v1/\\\"},\\\"heartbeat\\\":{\\\"interval\\\":\\\"30s\\\"},\\\"log\\\":{\\\"level\\\":\\\"debug\\\"},\\\"mqtt\\\":{\\\"mtls\\\":false,\\\"qos\\\":0,\\\"retain\\\":false,\\\"skip_tls_ver\\\":true,\\\"url\\\":\\\"tcp://mainflux-domain.com:1883\\\"},\\\"server\\\":{\\\"nats_url\\\":\\\"localhost:4222\\\",\\\"port\\\":\\\"9000\\\"},\\\"terminal\\\":{\\\"session_timeout\\\":\\\"30s\\\"}},\\\"export\\\":{\\\"exp\\\":{\\\"cache_db\\\":\\\"0\\\",\\\"cache_pass\\\":\\\"\\\",\\\"cache_url\\\":\\\"localhost:6379\\\",\\\"log_level\\\":\\\"debug\\\",\\\"nats\\\":\\\"nats://localhost:4222\\\",\\\"port\\\":\\\"8172\\\"},\\\"mqtt\\\":{\\\"ca_path\\\":\\\"ca.crt\\\",\\\"cert_path\\\":\\\"thing.crt\\\",\\\"channel\\\":\\\"\\\",\\\"host\\\":\\\"tcp://mainflux-domain.com:1883\\\",\\\"mtls\\\":false,\\\"password\\\":\\\"\\\",\\\"priv_key_path\\\":\\\"thing.key\\\",\\\"qos\\\":0,\\\"retain\\\":false,\\\"skip_tls_ver\\\":false,\\\"username\\\":\\\"\\\"},\\\"routes\\\":[{\\\"mqtt_topic\\\":\\\"\\\",\\\"nats_topic\\\":\\\"channels\\\",\\\"subtopic\\\":\\\"\\\",\\\"type\\\":\\\"mfx\\\",\\\"workers\\\":10},{\\\"mqtt_topic\\\":\\\"\\\",\\\"nats_topic\\\":\\\"export\\\",\\\"subtopic\\\":\\\"\\\",\\\"type\\\":\\\"default\\\",\\\"workers\\\":10}]}}\"\n}\n</code></pre> <ul> <li><code>external_id</code> is usually MAC address, but anything that suits applications requirements can be used</li> <li><code>external_key</code> is key that will be provided to agent process</li> <li><code>thing_id</code> is mainflux thing id</li> <li><code>channels</code> is 2-element array where first channel is CONTROL and second is DATA, both channels should be assigned to thing</li> <li><code>content</code> is used for configuring parameters of agent and export service.</li> </ul> <p>Then to start the agent service you can do it like this</p> <pre><code>git clone https://github.com/mainflux/agent\nmake\ncd build\n\nMF_AGENT_LOG_LEVEL=debug \\\nMF_AGENT_BOOTSTRAP_KEY=edged \\\nMF_AGENT_BOOTSTRAP_ID=34:e1:2d:e6:cf:03 ./mainflux-agent\n\n{\"level\":\"info\",\"message\":\"Requesting config for 34:e1:2d:e6:cf:03 from http://localhost:9013/things/bootstrap\",\"ts\":\"2019-12-05T04:47:24.98411512Z\"}\n{\"level\":\"info\",\"message\":\"Getting config for 34:e1:2d:e6:cf:03 from http://localhost:9013/things/bootstrap succeeded\",\"ts\":\"2019-12-05T04:47:24.995465239Z\"}\n{\"level\":\"info\",\"message\":\"Connected to MQTT broker\",\"ts\":\"2019-12-05T04:47:25.009645082Z\"}\n{\"level\":\"info\",\"message\":\"Agent service started, exposed port 9000\",\"ts\":\"2019-12-05T04:47:25.009755345Z\"}\n{\"level\":\"info\",\"message\":\"Subscribed to MQTT broker\",\"ts\":\"2019-12-05T04:47:25.012930443Z\"}\n</code></pre> <ul> <li><code>MF_AGENT_BOOTSTRAP_KEY</code> - is <code>external_key</code> in bootstrap configuration.</li> <li><code>MF_AGENT_BOOSTRAP_ID</code> - is <code>external_id</code> in bootstrap configuration.</li> </ul>"},{"location":"edge/#remote-execution-of-commands-via-agent","title":"Remote execution of commands via Agent","text":"<pre><code># Set connection parameters as environment variables in shell\nCH=`curl -s -S -X GET http://some-domain-name:9013/things/bootstrap/34:e1:2d:e6:cf:03 -H \"Authorization: edged\" -H 'Content-Type: application/json' | jq -r '.mainflux_channels[0].id'`\nTH=`curl -s  -S -X GET http://some-domain-name:9013/things/bootstrap/34:e1:2d:e6:cf:03 -H \"Authorization: edged\" -H 'Content-Type: application/json' | jq -r .mainflux_id`\nKEY=`curl -s  -S -X GET http://some-domain-name:9013/things/bootstrap/34:e1:2d:e6:cf:03 -H \"Authorization: edged\" -H 'Content-Type: application/json' | jq -r .mainflux_key`\n\n# Subscribe for response\nmosquitto_sub -d -u $TH -P $KEY  -t channels/$CH/messages/res/# -h some-domain-name -p 1883\n\n# Publish command e.g `ls`\nmosquitto_pub -d -u $TH -P $KEY  -t channels/$CH/messages/req -h some-domain-name -p 1883  -m '[{\"bn\":\"1:\", \"n\":\"exec\", \"vs\":\"ls, -l\"}]'\n</code></pre>"},{"location":"edge/#remote-terminal","title":"Remote terminal","text":"<p>This can be checked from the UI, click on the details for gateway and below the gateway parameters you will se box with prompt, if <code>agent</code> is running and it is properly connected you should be able to execute commands remotely.</p>"},{"location":"edge/#heartbeat","title":"Heartbeat","text":"<p>If there are services that are running on same gateway as <code>agent</code> and they are publishing heartbeat to the Message Broker subject <code>heartbeat.service_name.service</code> You can get the list of services by sending following mqtt message</p> <pre><code># View services that are sending heartbeat\nmosquitto_pub -d -u $TH -P $KEY  -t channels/$CH/messages/req -h some-domain-name -p 1883  -m '[{\"bn\":\"1:\", \"n\":\"service\", \"vs\":\"view\"}]'\n</code></pre> <p>Response can be observed on <code>channels/$CH/messages/res/#</code></p>"},{"location":"edge/#proxying-commands","title":"Proxying commands","text":"<p>You can send commands to services running on the same edge gateway as Agent if they are subscribed on same the Message Broker server and correct subject.</p> <p>Service commands are being sent via MQTT to topic:</p> <p><code>channels/&lt;control_channel_id&gt;/messages/services/&lt;service_name&gt;/&lt;subtopic&gt;</code></p> <p>when messages is received Agent forwards them to the Message Broker on subject:</p> <p><code>commands.&lt;service_name&gt;.&lt;subtopic&gt;</code></p> <p>Payload is up to the application and service itself.</p>"},{"location":"edge/#edgex","title":"EdgeX","text":"<p>Edgex control messages are sent and received over control channel. MF sends a control SenML of the following form:</p> <pre><code>[{\"bn\":\"&lt;uuid&gt;:\", \"n\":\"control\", \"vs\":\"&lt;cmd&gt;, &lt;param&gt;, edgexsvc1, edgexsvc2, \u2026, edgexsvcN\"}}]\n</code></pre> <p>For example,</p> <pre><code>[{\"bn\":\"1:\", \"n\":\"control\", \"vs\":\"operation, stop, edgex-support-notifications, edgex-core-data\"}]\n</code></pre> <p>Agent, on the other hand, returns a response SenML of the following form:</p> <pre><code>[{\"bn\":\"&lt;uuid&gt;:\", \"n\":\"&lt;&gt;\", \"v\":\"&lt;RESP&gt;\"}]\n</code></pre>"},{"location":"edge/#remote-commands","title":"Remote Commands","text":"<p>EdgeX defines SMA commands in the following RAML file</p> <p>Commands are:</p> <ul> <li>OPERATION</li> <li>CONFIG</li> <li>METRICS</li> <li>PING</li> </ul> <p>Operation</p> <pre><code>mosquitto_pub -u &lt;thing_id&gt; -P &lt;thing_key&gt; -t channels/&lt;channel_id&gt;/messages/req -h localhost -m '[{\"bn\":\"1:\", \"n\":\"control\", \"vs\":\"edgex-operation, start, edgex-support-notifications, edgex-core-data\"}]'\n</code></pre> <p>Config</p> <pre><code>mosquitto_pub -u &lt;thing_id&gt; -P &lt;thing_key&gt; -t channels/&lt;channel_id&gt;/messages/req -h localhost -m '[{\"bn\":\"1:\", \"n\":\"control\", \"vs\":\"edgex-config, edgex-support-notifications, edgex-core-data\"}]'\n</code></pre> <p>Metrics</p> <pre><code>mosquitto_pub -u &lt;thing_id&gt; -P &lt;thing_key&gt; -t channels/&lt;channel_id&gt;/messages/req -h localhost -m '[{\"bn\":\"1:\", \"n\":\"control\", \"vs\":\"edgex-metrics, edgex-support-notifications, edgex-core-data\"}]'\n</code></pre> <p>If you subscribe to</p> <pre><code>mosquitto_sub -u &lt;thing_id&gt; -P &lt;thing_key&gt; -t channels/&lt;channel_id&gt;/messages/#\n</code></pre> <p>You can observe commands and response from commands executed against edgex</p> <pre><code>[{\"bn\":\"1:\", \"n\":\"control\", \"vs\":\"edgex-metrics, edgex-support-notifications, edgex-core-data\"}]                                                                            \n[{\"bn\":\"1\",\"n\":\"edgex-metrics\",\"vs\":\"{\\\"Metrics\\\":{\\\"edgex-core-data\\\":{\\\"CpuBusyAvg\\\":15.568632467698606,\\\"Memory\\\":{\\\"Alloc\\\":2040136,\\\"Frees\\\":876344,\\\"LiveObjects\\\":15134,\\\"Mallocs\\\":891478,\\\"Sys\\\":73332984,\\\"TotalAlloc\\\":80657464}},\\\"edgex-support-notifications\\\":{\\\"CpuBusyAvg\\\":14.65381169745318,\\\"Memory\\\":{\\\"Alloc\\\":961784,\\\"Frees\\\":127430,\\\"LiveObjects\\\":6095,\\\"Mallocs\\\":133525,\\\"Sys\\\":72808696,\\\"TotalAlloc\\\":11665416}}}}\\n\"}]\n</code></pre>"},{"location":"edge/#export","title":"Export","text":"<p>Mainflux Export service can send message from one Mainflux cloud to another via MQTT, or it can send messages from edge gateway to Mainflux Cloud. Export service is subscribed to local message bus and connected to MQTT broker in the cloud. Messages collected on local message bus are redirected to the cloud. When connection is lost, if QoS2 is used, messages from the local bus are stored into file or in memory to be resent upon reconnection. Additonaly <code>Export</code> service publishes liveliness status to <code>Agent</code> via the Message Broker subject <code>heartbeat.export.service</code></p>"},{"location":"edge/#install","title":"Install","text":"<p>Get the code:</p> <pre><code>go get github.com/mainflux/export\ncd $GOPATH/github.com/mainflux/export\n</code></pre> <p>Make:</p> <pre><code>make\n</code></pre>"},{"location":"edge/#usage","title":"Usage","text":"<pre><code>cd build\n./mainflux-export\n</code></pre>"},{"location":"edge/#configuration","title":"Configuration","text":"<p>By default <code>Export</code> service looks for config file at <code>../configs/config.toml</code> if no env vars are specified.  </p> <pre><code>[exp]\n  log_level = \"debug\"\n  nats = \"localhost:4222\"\n  port = \"8170\"\n\n[mqtt]\n  username = \"&lt;thing_id&gt;\"\n  password = \"&lt;thing_password&gt;\"\n  ca_path = \"ca.crt\"\n  client_cert = \"\"\n  client_cert_key = \"\"\n  client_cert_path = \"thing.crt\"\n  client_priv_key_path = \"thing.key\"\n  mtls = \"false\"\n  priv_key = \"thing.key\"\n  retain = \"false\"\n  skip_tls_ver = \"false\"\n  url = \"tcp://mainflux.com:1883\"\n\n[[routes]]\n  mqtt_topic = \"channel/&lt;channel_id&gt;/messages\"\n  subtopic = \"subtopic\"\n  nats_topic = \"export\"\n  type = \"default\"\n  workers = 10\n\n[[routes]]\n  mqtt_topic = \"channel/&lt;channel_id&gt;/messages\"\n  subtopic = \"subtopic\"\n  nats_topic = \"channels\"\n  type = \"mfx\"\n  workers = 10\n</code></pre>"},{"location":"edge/#environment-variables","title":"Environment variables","text":"<p>Service will first look for <code>MF_EXPORT_CONFIG_FILE</code> for configuration and if not found it will be configured with env variables and new config file specified with <code>MF_EXPORT_CONFIG_FILE</code> (default value will be used if none specified) will be saved with values populated from env vars. The service is configured using the environment variables as presented in the table. Note that any unset variables will be replaced with their default values.</p> <p>For values in environment variables to take effect make sure that there is no <code>MF_EXPORT_CONFIG_FILE</code> file.</p> <p>If you run with environment variables you can create config file:</p> <pre><code>MF_EXPORT_PORT=8178 \\\nMF_EXPORT_LOG_LEVEL=debug \\\nMF_EXPORT_MQTT_HOST=tcp://localhost:1883 \\\nMF_EXPORT_MQTT_USERNAME=&lt;thing_id&gt; \\\nMF_EXPORT_MQTT_PASSWORD=&lt;thing_key&gt; \\\nMF_EXPORT_MQTT_CHANNEL=&lt;channel_id&gt; \\\nMF_EXPORT_MQTT_SKIP_TLS=true \\\nMF_EXPORT_MQTT_MTLS=false \\\nMF_EXPORT_MQTT_CA=ca.crt \\\nMF_EXPORT_MQTT_CLIENT_CERT=thing.crt \\\nMF_EXPORT_MQTT_CLIENT_PK=thing.key \\\nMF_EXPORT_CONFIG_FILE=export.toml \\\n../build/mainflux-export&amp;\n</code></pre> <p>Values from environment variables will be used to populate export.toml</p>"},{"location":"edge/#http-port","title":"Http port","text":"<ul> <li><code>port</code> - HTTP port where status of <code>Export</code> service can be fetched.</li> </ul> <pre><code>curl -X GET http://localhost:8170/health\n'{\"status\": \"pass\", \"version\":\"0.12.1\", \"commit\":\"57cca9677721025da055c47957fc3e869e0325aa\" , \"description\":\"export service\", \"build_time\": \"2022-01-19_10:13:17\"}'\n</code></pre>"},{"location":"edge/#mqtt-connection","title":"MQTT connection","text":"<p>To establish connection to MQTT broker following settings are needed: - <code>username</code> - Mainflux  - <code>password</code> - Mainflux  - <code>url</code> - url of MQTT broker <p>Additionally, you will need MQTT client certificates if you enable mTLS. To obtain certificates <code>ca.crt</code>, <code>thing.crt</code> and key <code>thing.key</code> follow instructions here or here.</p>"},{"location":"edge/#mtls","title":"MTLS","text":"<p>To setup <code>MTLS</code> connection <code>Export</code> service requires client certificate and <code>mtls</code> in config or <code>MF_EXPORT_MQTT_MTLS</code> must be set to <code>true</code>. Client certificate can be provided in a file, <code>client_cert_path</code> and <code>client_cert_key_path</code> are used for specifying path to certificate files. If MTLS is used and no certificate file paths are specified then <code>Export</code> will look in <code>client_cert</code> and <code>client_cert_key</code> of config file expecting certificate content stored as string.</p>"},{"location":"edge/#routes","title":"Routes","text":"<p>Routes are being used for specifying which subscriber's topic(subject) goes to which publishing topic. Currently only MQTT is supported for publishing. To match Mainflux requirements <code>mqtt_topic</code> must contain <code>channel/&lt;channel_id&gt;/messages</code>, additional subtopics can be appended.</p> <ul> <li><code>mqtt_topic</code> - <code>channel/&lt;channel_id&gt;/messages/&lt;custom_subtopic&gt;</code></li> <li><code>nats_topic</code> - <code>Export</code> service will be subscribed to the Message Broker subject <code>&lt;nats_topic&gt;.&gt;</code></li> <li><code>subtopic</code> - messages will be published to MQTT topic <code>&lt;mqtt_topic&gt;/&lt;subtopic&gt;/&lt;nats_subject&gt;</code>, where dots in nats_subject are replaced with '/'</li> <li><code>workers</code> - specifies number of workers that will be used for message forwarding.</li> <li><code>type</code> - specifies message transformation:<ul> <li><code>default</code> is for sending messages as they are received on the Message Broker with no transformation (so they should be in SenML or JSON format if we want to persist them in Mainflux in cloud). If you don't want to persist messages in Mainflux or you are not exporting to Mainflux cloud - message format can be anything that suits your application as message passes untransformed.</li> <li><code>mfx</code> is for messages that are being picked up on internal Mainflux Message Broker bus. When using <code>Export</code> along with Mainflux deployed on gateway (Fig. 1) messages coming from MQTT broker that are published to the Message Broker bus are Mainflux message. Using <code>mfx</code> type will extract payload and <code>export</code> will publish it to <code>mqtt_topic</code>. Extracted payload is SenML or JSON if we want to persist messages. <code>nats_topic</code> in this case must be <code>channels</code>, or if you want to pick messages from a specific channel in local Mainflux instance to be exported to cloud you can put <code>channels.&lt;local_mainflux_channel_id&gt;</code>.</li> </ul> </li> </ul> <p>Before running <code>Export</code> service edit <code>configs/config.toml</code> and provide <code>username</code>, <code>password</code> and <code>url</code>  * <code>username</code> - matches <code>thing_id</code> in Mainflux cloud instance  * <code>password</code> - matches <code>thing_key</code>  * <code>channel</code> - MQTT part of the topic where to publish MQTT data (<code>channel/&lt;channel_id&gt;/messages</code> is format of mainflux MQTT topic) and plays a part in authorization.</p> <p>If Mainflux and Export service are deployed on same gateway <code>Export</code> can be configured to send messages from Mainflux internal Message Broker bus to Mainflux in a cloud. In order for <code>Export</code> service to listen on Mainflux Message Broker deployed on the same machine Message Broker port must be exposed. Edit Mainflux docker-compose.yml. Default Message Broker, NATS, section must look like below:</p> <pre><code>  nats:\n    image: nats:1.3.0\n    container_name: mainflux-nats\n    restart: on-failure\n    networks:\n      - mainflux-base-net\n    ports:\n      - 4222:4222\n</code></pre>"},{"location":"edge/#how-to-save-config-via-agent","title":"How to save config via agent","text":"<p>Configuration file for <code>Export</code> service can be sent over MQTT using Agent service.</p> <pre><code>mosquitto_pub -u &lt;thing_id&gt; -P &lt;thing_key&gt; -t channels/&lt;control_ch_id&gt;/messages/req -h localhost -p 18831  -m  \"[{\\\"bn\\\":\\\"1:\\\", \\\"n\\\":\\\"config\\\", \\\"vs\\\":\\\"save, export, &lt;config_file_path&gt;, &lt;file_content_base64&gt;\\\"}]\"\n</code></pre> <p><code>vs=\"save, export, config_file_path, file_content_base64\"</code> - vs determines where to save file and contains file content in base64 encoding payload:</p> <pre><code>b,_ := toml.Marshal(export.Config)\npayload := base64.StdEncoding.EncodeToString(b)\n</code></pre>"},{"location":"edge/#using-configure-script","title":"Using configure script","text":"<p>There is a <code>configuration.sh</code> script in a <code>scripts</code> directory that can be used for automatic configuration and start up of remotely deployed <code>export</code>. For this to work it is presumed that <code>mainflux-export</code> and <code>scripts/export_start</code> are placed in executable path on remote device. Additionally this script requires that remote device is provisioned following the steps described for provision service.</p> <p>To run it first edit script to set parameters</p> <pre><code>MTLS=false\nEXTERNAL_KEY='raspberry'\nEXTERNAL_ID='pi'\nMAINFLUX_HOST='mainflux.com'\nMAINFLUX_USER_EMAIL='edge@email.com'\nMAINFLUX_USER_PASSWORD='12345678'\n</code></pre> <p><code>EXTERNAL_KEY</code> and <code>EXTERNAL_ID</code> are parameters posted to <code>/mapping</code> endpoint of <code>provision</code> service, <code>MAINFLUX_HOST</code> is location of cloud instance of Mainflux that <code>export</code> should connect to and <code>MAINFLUX_USER_EMAIL</code> and <code>MAINFLUX_USER_PASSWORD</code> are users credentials in the cloud.</p>"},{"location":"edge/#example-deployment","title":"Example deployment","text":""},{"location":"edge/#edge-deployment","title":"Edge deployment","text":"<p>The following are steps that are an example usage of Mainflux components to connect edge with cloud. We will start Mainflux in the cloud with additional services Bootstrap and Provision. Using Bootstrap and Provision we will create a configuration for use in gateway deployment. On the gateway we will start services Agent and Export using previously created configuration.</p>"},{"location":"edge/#services-in-the-cloud","title":"Services in the cloud","text":"<p>Start the Mainflux:</p> <pre><code>docker-compose -f docker/docker-compose.yml up\n</code></pre> <p>Start the Bootstrap service:</p> <pre><code>docker-compose -f docker/addons/bootstrap/docker-compose.yml up\n</code></pre> <p>Start the Provision service</p> <pre><code>docker-compose -f docker/addons/provision/docker-compose.yml up\n</code></pre> <p>Create user:</p> <pre><code>mainflux-cli -m http://localhost:9002 users create test@email.com 12345678\n</code></pre> <p>Obtain user token:</p> <pre><code>mainflux-cli -m http://localhost:9002 users token test@email.com 12345678\n\ncreated: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODk5MDQ4MDQsImlhdCI6MTU4OTg2ODgwNCwiaXNzIjoibWFpbmZsdXguYXV0aG4iLCJzdWIiOiJ0ZXN0QGVtYWlsLmNvbSIsInR5cGUiOjB9.VSwpGoflOLqrHlCGoVVFPBdnnvsAhv2gc3EomXg9yM0\n\nTOK=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODk5MDQ4MDQsImlhdCI6MTU4OTg2ODgwNCwiaXNzIjoibWFpbmZsdXguYXV0aG4iLCJzdWIiOiJ0ZXN0QGVtYWlsLmNvbSIsInR5cGUiOjB9.VSwpGoflOLqrHlCGoVVFPBdnnvsAhv2gc3EomXg9yM0\n</code></pre> <p>Provision a gateway:</p> <pre><code>curl -s -S  -X POST  http://localhost:9016/mapping -H \"Authorization: Bearer $TOKEN\" -H 'Content-Type: application/json'   -d '{\"name\":\"testing\",  \"external_id\" : \"54:FG:66:DC:43\", \"external_key\":\"223334fw2\" }' | jq\n</code></pre> <pre><code>{\n  \"things\": [\n    {\n      \"id\": \"88529fb2-6c1e-4b60-b9ab-73b5d89f7404\",\n      \"name\": \"thing\",\n      \"key\": \"3529c1bb-7211-4d40-9cd8-b05833196093\",\n      \"metadata\": {\n        \"external_id\": \"54:FG:66:DC:43\"\n      }\n    }\n  ],\n  \"channels\": [\n    {\n      \"id\": \"1aa3f736-0bd3-44b5-a917-a72cc743f633\",\n      \"name\": \"control-channel\",\n      \"metadata\": {\n        \"type\": \"control\"\n      }\n    },\n    {\n      \"id\": \"e2adcfa6-96b2-425d-8cd4-ff8cb9c056ce\",\n      \"name\": \"data-channel\",\n      \"metadata\": {\n        \"type\": \"data\"\n      }\n    }\n  ],\n  \"whitelisted\": {\n    \"88529fb2-6c1e-4b60-b9ab-73b5d89f7404\": true\n  }\n}\n</code></pre> <p>Parameters  and  are representing the gateway. <code>Provision</code> will use them to create a bootstrap configuration that will make a relation with Mainflux entities used for connection, authentication and authorization <code>thing</code> and <code>channel</code>. These parameters will be used by <code>Agent</code> service on the gateway to retrieve that information and establish a connection with the cloud."},{"location":"edge/#services-on-the-edge","title":"Services on the Edge","text":""},{"location":"edge/#agent_1","title":"Agent","text":"<p>Start the [NATS][nats] and Agent service:</p> <pre><code>gnatsd\nMF_AGENT_BOOTSTRAP_ID=54:FG:66:DC:43 \\\nMF_AGENT_BOOTSTRAP_KEY=\"223334fw2\" \\\nMF_AGENT_BOOTSTRAP_URL=http://localhost:9013/things/bootstrap \\\nbuild/mainflux-agent\n{\"level\":\"info\",\"message\":\"Requesting config for 54:FG:66:DC:43 from http://localhost:9013/things/bootstrap\",\"ts\":\"2020-05-07T15:50:58.041145096Z\"}\n{\"level\":\"info\",\"message\":\"Getting config for 54:FG:66:DC:43 from http://localhost:9013/things/bootstrap succeeded\",\"ts\":\"2020-05-07T15:50:58.120779415Z\"}\n{\"level\":\"info\",\"message\":\"Saving export config file /configs/export/config.toml\",\"ts\":\"2020-05-07T15:50:58.121602229Z\"}\n{\"level\":\"warn\",\"message\":\"Failed to save export config file Error writing config file: open /configs/export/config.toml: no such file or directory\",\"ts\":\"2020-05-07T15:50:58.121752142Z\"}\n{\"level\":\"info\",\"message\":\"Client agent-88529fb2-6c1e-4b60-b9ab-73b5d89f7404 connected\",\"ts\":\"2020-05-07T15:50:58.128500603Z\"}\n{\"level\":\"info\",\"message\":\"Agent service started, exposed port 9003\",\"ts\":\"2020-05-07T15:50:58.128531057Z\"}\n</code></pre>"},{"location":"edge/#export_1","title":"Export","text":"<pre><code>git clone https://github.com/mainflux/export\nmake\n</code></pre> <p>Edit the <code>configs/config.toml</code> setting - <code>username</code> - thing from the results of provision request. - <code>password</code> - key from the results of provision request. - <code>mqtt_topic</code> - in routes set to <code>channels/&lt;channel_data_id&gt;/messages</code> from results of provision. - <code>nats_topic</code> - whatever you need, export will subscribe to <code>export.&lt;nats_topic&gt;</code> and forward messages to MQTT. - <code>host</code> - url of MQTT broker.</p> <pre><code>[exp]\n  cache_pass = \"\"\n  cache_url = \"\"\n  log_level = \"debug\"\n  nats = \"localhost:4222\"\n  port = \"8170\"\n\n[mqtt]\n  ca_path = \"\"\n  cert_path = \"\"\n  host = \"tcp://localhost:1883\"\n  mtls = false\n  password = \"3529c1bb-7211-4d40-9cd8-b05833196093\"\n  priv_key_path = \"\"\n  qos = 0\n  retain = false\n  skip_tls_ver = false\n  username = \"88529fb2-6c1e-4b60-b9ab-73b5d89f7404\"\n\n[[routes]]\n  mqtt_topic = \"channels/e2adcfa6-96b2-425d-8cd4-ff8cb9c056ce/messages\"\n  nats_topic = \"&gt;\"\n  workers = 10\n</code></pre> <pre><code>cd build\n./mainflux-export\n2020/05/07 17:36:57 Configuration loaded from file ../configs/config.toml\n{\"level\":\"info\",\"message\":\"Export service started, exposed port :8170\",\"ts\":\"2020-05-07T15:36:57.528398548Z\"}\n{\"level\":\"debug\",\"message\":\"Client export-88529fb2-6c1e-4b60-b9ab-73b5d89f7404 connected\",\"ts\":\"2020-05-07T15:36:57.528405818Z\"}\n</code></pre>"},{"location":"edge/#testing-export","title":"Testing Export","text":"<pre><code>git clone https://github.com/nats-io/nats.go\ncd github.com/nats-io/nats.go/examples/nats-pub\ngo run main.go -s http://localhost:4222 export.test \"[{\\\"bn\\\":\\\"test\\\"}]\";\n</code></pre> <p>We have configured route for export, <code>nats_topic = \"&gt;\"</code> means that it will listen to <code>NATS</code> subject <code>export.&gt;</code> and <code>mqtt_topic</code> is configured so that data will be sent to MQTT broker on topic <code>channels/e2adcfa6-96b2-425d-8cd4-ff8cb9c056ce/messages</code> with appended <code>NATS</code> subject.</p> <p>In terminal where export is started you should see following message:</p> <pre><code>{\"level\":\"debug\",\"message\":\"Published to: export.test, payload: [{\\\"bn\\\":\\\"test\\\"}]\",\"ts\":\"2020-05-08T15:14:15.757298992Z\"}\n</code></pre> <p>In Mainflux <code>mqtt</code> service:</p> <pre><code>mainflux-mqtt   | {\"level\":\"info\",\"message\":\"Publish - client ID export-88529fb2-6c1e-4b60-b9ab-73b5d89f7404 to the topic: channels/e2adcfa6-96b2-425d-8cd4-ff8cb9c056ce/messages/export/test\",\"ts\":\"2020-05-08T15:16:02.999684791Z\"}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#step-1-run-the-system","title":"Step 1 - Run the System","text":"<p>Before proceeding, install the following prerequisites:</p> <ul> <li>Docker (version 18.09)</li> <li>Docker compose (version 1.24.1)</li> </ul> <p>Once everything is installed, execute the following command from project root:</p> <pre><code>make run\n</code></pre> <p>This will start Mainflux docker composition, which will output the logs from the containers.</p>"},{"location":"getting-started/#step-2-install-the-cli","title":"Step 2 - Install the CLI","text":"<p>Open a new terminal from which you can interact with the running Mainflux system. The easiest way to do this is by using the Mainflux CLI, which can be downloaded as a tarball from GitHub (here we use release <code>0.13.0</code> but be sure to use the latest CLI release):</p> <pre><code>wget -O- https://github.com/mainflux/mainflux/releases/download/0.13.0/mainflux-cli_0.13.0_linux-amd64.tar.gz | tar xvz -C $GOBIN\n</code></pre> <p>Make sure that <code>$GOBIN</code> is added to your <code>$PATH</code> so that <code>mainflux-cli</code> command can be accessible system-wide</p>"},{"location":"getting-started/#build-mainflux-cli","title":"Build mainflux-cli","text":"<p>Build <code>mainflux-cli</code> if the pre-built CLI is not compatible with your OS, i.e MacOS. Please see the CLI for further details.</p>"},{"location":"getting-started/#step-3-provision-the-system","title":"Step 3 - Provision the System","text":"<p>Once installed, you can use the CLI to quick-provision the system for testing:</p> <pre><code>mainflux-cli provision test\n</code></pre> <p>This command actually creates a temporary testing user, logs it in, then creates two things and two channels on behalf of this user. This quickly provisions a Mainflux system with one simple testing scenario.</p> <p>You can read more about system provisioning in the dedicated Provisioning chapter</p> <p>Output of the command follows this pattern:</p> <pre><code>{\n  \"email\": \"friendly_beaver@email.com\",\n  \"password\": \"12345678\"\n}\n\n\n\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NDcwMjE3ODAsImlhdCI6MTU0Njk4NTc4MCwiaXNzIjoibWFpbmZsdXgiLCJzdWIiOiJmcmllbmRseV9iZWF2ZXJAZW1haWwuY29tIn0.Tyk31Ae680KqMrDqP895PRZg_GUytLE0IMIR_o3oO7o\"\n\n\n[\n  {\n    \"id\": \"513d02d2-16c1-4f23-98be-9e12f8fee898\",\n    \"key\": \"69590b3a-9d76-4baa-adae-9b5fec0ea14f\",\n    \"name\": \"d0\",\n  },\n  {\n    \"id\": \"bf78ca98-2fef-4cfc-9f26-e02da5ecdf67\",\n    \"key\": \"840c1ea1-2e8d-4809-a6d3-3433a5c489d2\",\n    \"name\": \"d1\",\n  }\n]\n\n\n[\n  {\n    \"id\": \"b7bfc4b6-c18d-47c5-b343-98235c5acc19\",\n    \"name\": \"c0\"\n  },\n  {\n    \"id\": \"378678cd-891b-4a39-b026-869938783f54\",\n    \"name\": \"c1\"\n  }\n]\n</code></pre> <p>In the Mainflux system terminal (where docker compose is running) you should see following logs:</p> <pre><code>mainflux-users  | {\"level\":\"info\",\"message\":\"Method register for user friendly_beaver@email.com took 97.573974ms to complete without errors.\",\"ts\":\"2019-01-08T22:16:20.745989495Z\"}\nmainflux-users  | {\"level\":\"info\",\"message\":\"Method login for user friendly_beaver@email.com took 69.308406ms to complete without errors.\",\"ts\":\"2019-01-08T22:16:20.820610461Z\"}\nmainflux-users  | {\"level\":\"info\",\"message\":\"Method identity for client friendly_beaver@email.com took 50.903\u00b5s to complete without errors.\",\"ts\":\"2019-01-08T22:16:20.822208948Z\"}\nmainflux-things | {\"level\":\"info\",\"message\":\"Method add_thing for token eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NDcwMjE3ODAsImlhdCI6MTU0Njk4NTc4MCwiaXNzIjoibWFpbmZsdXgiLCJzdWIiOiJmcmllbmRseV9iZWF2ZXJAZW1haWwuY29tIn0.Tyk31Ae680KqMrDqP895PRZg_GUytLE0IMIR_o3oO7o and thing 513d02d2-16c1-4f23-98be-9e12f8fee898 took 4.865299ms to complete without errors.\",\"ts\":\"2019-01-08T22:16:20.826786175Z\"}\n\n...\n\n</code></pre> <p>This proves that these provisioning commands were sent from the CLI to the Mainflux system.</p>"},{"location":"getting-started/#step-4-send-messages","title":"Step 4 - Send Messages","text":"<p>Once system is provisioned, a <code>thing</code> can start sending messages on a <code>channel</code>:</p> <pre><code>mainflux-cli messages send &lt;channel_id&gt; '[{\"bn\":\"some-base-name:\",\"bt\":1.276020076001e+09, \"bu\":\"A\",\"bver\":5, \"n\":\"voltage\",\"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"t\":-5,\"v\":1.2}, {\"n\":\"current\",\"t\":-4,\"v\":1.3}]' &lt;thing_key&gt;\n</code></pre> <p>For example:</p> <pre><code>mainflux-cli messages send b7bfc4b6-c18d-47c5-b343-98235c5acc19 '[{\"bn\":\"some-base-name:\",\"bt\":1.276020076001e+09, \"bu\":\"A\",\"bver\":5, \"n\":\"voltage\",\"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"t\":-5,\"v\":1.2}, {\"n\":\"current\",\"t\":-4,\"v\":1.3}]' 69590b3a-9d76-4baa-adae-9b5fec0ea14f\n</code></pre> <p>In the Mainflux system terminal you should see following logs:</p> <pre><code>mainflux-things | {\"level\":\"info\",\"message\":\"Method can_access for channel b7bfc4b6-c18d-47c5-b343-98235c5acc19 and thing 513d02d2-16c1-4f23-98be-9e12f8fee898 took 1.410194ms to complete without errors.\",\"ts\":\"2019-01-08T22:19:30.148097648Z\"}\nmainflux-http   | {\"level\":\"info\",\"message\":\"Method publish took 336.685\u00b5s to complete without errors.\",\"ts\":\"2019-01-08T22:19:30.148689601Z\"}\n</code></pre> <p>This proves that messages have been correctly sent through the system via the protocol adapter (<code>mainflux-http</code>).</p>"},{"location":"groups/","title":"Groups","text":""},{"location":"groups/#auth-service","title":"Auth service","text":"<p>For grouping Mainflux entities there are <code>groups</code> object in the <code>auth</code> service. Grouping of entities can be done for <code>things</code> and <code>users</code> but additionally you can use <code>groups</code> for grouping some external entities as well. Groups are organized like a tree, group can have one parent and children. Group with no parent is root of the tree.</p>"},{"location":"groups/#create-a-group","title":"Create a group","text":"<pre><code>curl -is -S -X POST http://localhost/groups -d '{\"name\":\"&lt;group_name&gt;\",\"description\":\"&lt;group_description&gt;\",\"parent_id\":\"&lt;parent_id&gt;\",\"metadata\":&lt;group_metadata&gt;}' -H 'Content-Type: application/json' -H \"Authorization: Bearer $TOKEN\"                    \nHTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Fri, 09 Apr 2021 08:02:02 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /groups/01F2TTDYGMP6DW083NE6E0DKH2\nAccess-Control-Expose-Headers: Location\n</code></pre> <ul> <li>group_name - name of the group</li> <li>group_description - description of group up to 1024 characters.</li> <li>parent_id - id of parent group, if not specified created group is tree root.</li> <li>metadata - custom metadata that can be attached to group object for specific application needs.</li> </ul>"},{"location":"groups/#fetch-a-group","title":"Fetch a group","text":"<pre><code>curl -s -S -X GET http://localhost/groups/01F2TTDYGMP6DW083NE6E0DKH2 -H \"Authorization: Bearer $TOKEN\"\n</code></pre>"},{"location":"groups/#create-a-child","title":"Create a child","text":"<pre><code>curl -is -S -X POST http://localhost/groups -d '{\"name\":\"test1\",\"description\":\"&lt;group_description&gt;\",\"parent_id\":\"01F2TTDYGMP6DW083NE6E0DKH2\",\"metadata\":{\"group_attr\":\"attr_value\"}}' -H 'Content-Type: application/json' -H \"Authorization: Bearer $TOKEN\"\nHTTP/1.1 201 Created\nServer: nginx/1.16.0\nDate: Fri, 09 Apr 2021 08:09:37 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nLocation: /groups/01F2TTVV5NJH63FE5KXMNPWB8P\nAccess-Control-Expose-Headers: Location\n</code></pre>"},{"location":"groups/#fetch-a-child-group","title":"Fetch a child group","text":"<pre><code>curl -s -S -X GET http://localhost/groups/01F2TTVV5NJH63FE5KXMNPWB8P -H \"Authorization: Bearer $TOKEN\" | jq\n{\n  \"id\": \"01F2TTVV5NJH63FE5KXMNPWB8P\",\n  \"name\": \"test1\",\n  \"owner_id\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n  \"parent_id\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n  \"description\": \"group for test\",\n  \"metadata\": {\n    \"group_attr\": \"attr_value\"\n  },\n  \"level\": 1,\n  \"created_at\": \"2021-04-09T08:09:37.718Z\",\n  \"updated_at\": \"2021-04-09T08:09:37.718Z\"\n}\n</code></pre> <ul> <li>owner_id - is attached by service, it is id of the user that issued create request.</li> <li>level - is generated by service, it represents a level in a tree hierarchy</li> <li>created_at - time of creation, generated by service.</li> <li>updated_at - time of update, generated by service.</li> </ul>"},{"location":"groups/#fetch-group-hierarchy","title":"Fetch group hierarchy","text":"<p>To fetch a group hierarchy you can either fetch children for a group or a direct ascendant line</p>"},{"location":"groups/#fetch-a-parent","title":"Fetch a parent","text":"<pre><code> curl -s -S -X GET http://localhost/groups/&lt;group_id&gt;/parents?tree=true&amp;level=5 -H \"Authorization: Bearer &lt;user_token&gt;\" | jq\n{\n  \"total\": 2,\n  \"level\": 1,\n  \"name\": \"\",\n  \"groups\": [\n    {\n      \"id\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n      \"name\": \"test\",\n      \"owner_id\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n      \"description\": \"group for test\",\n      \"metadata\": {\n        \"group_attr\": \"attr_value\"\n      },\n      \"level\": 1,\n      \"path\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n      \"children\": [\n        {\n          \"id\": \"01F2TTVV5NJH63FE5KXMNPWB8P\",\n          \"name\": \"test1\",\n          \"owner_id\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n          \"parent_id\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n          \"description\": \"group for test\",\n          \"metadata\": {\n            \"group_attr\": \"attr_value\"\n          },\n          \"level\": 2,\n          \"path\": \"01F2TTDYGMP6DW083NE6E0DKH2.01F2TTVV5NJH63FE5KXMNPWB8P\",\n          \"created_at\": \"2021-04-09T08:09:37.718Z\",\n          \"updated_at\": \"2021-04-09T08:09:37.718Z\"\n        }\n      ],\n      \"created_at\": \"2021-04-09T08:02:02.389Z\",\n      \"updated_at\": \"2021-04-09T08:02:02.389Z\"\n    }\n  ]\n}\n</code></pre> <ul> <li>tree - if true response is JSON that represent a groups tree structure. If ommited or <code>false</code> than groups will be retrieve as list</li> <li>level - limits the hierarchy to be retrieved. Max level to be fetched in one request is 5.</li> </ul>"},{"location":"groups/#fetch-children","title":"Fetch children","text":"<pre><code>curl -s -S -X GET http://localhost/groups/01F2TTDYGMP6DW083NE6E0DKH2/children\\?tree\\=true\\&amp;level\\=5 -H \"Authorization: Bearer $TOKEN\" | jq\n{\n  \"total\": 3,\n  \"level\": 5,\n  \"name\": \"\",\n  \"groups\": [\n    {\n      \"id\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n      \"name\": \"test\",\n      \"owner_id\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n      \"description\": \"group for test\",\n      \"metadata\": {\n        \"group_attr\": \"attr_value\"\n      },\n      \"level\": 1,\n      \"path\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n      \"children\": [\n        {\n          \"id\": \"01F2TTVV5NJH63FE5KXMNPWB8P\",\n          \"name\": \"test1\",\n          \"owner_id\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n          \"parent_id\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n          \"description\": \"group for test\",\n          \"metadata\": {\n            \"group_attr\": \"attr_value\"\n          },\n          \"level\": 2,\n          \"path\": \"01F2TTDYGMP6DW083NE6E0DKH2.01F2TTVV5NJH63FE5KXMNPWB8P\",\n          \"created_at\": \"2021-04-09T08:09:37.718Z\",\n          \"updated_at\": \"2021-04-09T08:09:37.718Z\"\n        },\n        {\n          \"id\": \"01F2TTJPXSZ7K941T57MX3V03M\",\n          \"name\": \"test\",\n          \"owner_id\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n          \"parent_id\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n          \"description\": \"group for test\",\n          \"metadata\": {\n            \"group_attr\": \"attr_value\"\n          },\n          \"level\": 2,\n          \"path\": \"01F2TTDYGMP6DW083NE6E0DKH2.01F2TTJPXSZ7K941T57MX3V03M\",\n          \"created_at\": \"2021-04-09T08:04:38.458Z\",\n          \"updated_at\": \"2021-04-09T08:04:38.458Z\"\n        }\n      ],\n      \"created_at\": \"2021-04-09T08:02:02.389Z\",\n      \"updated_at\": \"2021-04-09T08:02:02.389Z\"\n    }\n  ]\n}\n</code></pre>"},{"location":"groups/#assign-a-member-to-a-group","title":"Assign a member to a group","text":"<p>You can assign members to a group by putting entity ids into a group For example assigning users to a group</p> <pre><code>curl -isSX POST http://localhost/groups/&lt;group_id&gt;/members -d '{\"members\":[\"&lt;user_id1&gt;\",...\"&lt;user_idN&gt;\"],\"type\":\"users\"}' -H \"Authorization: Bearer $TOKEN\" -H 'Content-Type: application/json'\nHTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Fri, 09 Apr 2021 09:40:35 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>Or assigning things to a group</p> <pre><code>curl -isSX POST http://localhost/groups/01F2TTDYGMP6DW083NE6E0DKH2/members -d '{\"members\":[\"a0b1d516-67c6-4e8d-8ea2-ad4aff444ca3\",\"9a036414-5d47-4122-9e58-b3b6953a2097\"],\"type\":\"things\"}' -H \"Authorization: Bearer $TOKEN\" -H 'Content-Type: application/json'\nHTTP/1.1 200 OK\nServer: nginx/1.16.0\nDate: Fri, 09 Apr 2021 09:43:24 GMT\nContent-Type: application/json\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Expose-Headers: Location\n</code></pre> <p>To fetch members you can use endpoint on <code>auth</code>, <code>things</code> or <code>users</code> service. Endpoint on auth service only retrieves member ids. Endpoints on <code>things</code> and <code>users</code> will retrieve full objects.</p>"},{"location":"groups/#fetching-members","title":"Fetching members","text":""},{"location":"groups/#fetching-from-auth-service","title":"Fetching from <code>auth</code> service","text":"<pre><code>curl -sSX GET http://localhost/groups/01F2TTDYGMP6DW083NE6E0DKH2/members  -H \"Authorization: Bearer $TOKEN\" | jq\n{\n  \"limit\": 10,\n  \"total\": 0,\n  \"name\": \"\",\n  \"Members\": [\n    {\n      \"ID\": \"5ec9f5f4-5221-43f4-a56f-9594ab110efa\",\n      \"Type\": \"users\"\n    },\n    {\n      \"ID\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n      \"Type\": \"users\"\n    },\n    {\n      \"ID\": \"a0b1d516-67c6-4e8d-8ea2-ad4aff444ca3\",\n      \"Type\": \"things\"\n    },\n    {\n      \"ID\": \"9a036414-5d47-4122-9e58-b3b6953a2097\",\n      \"Type\": \"things\"\n    }\n  ]\n}\n</code></pre> <p>You can filter by <code>type</code></p> <pre><code>curl -sSX GET http://localhost/groups/01F2TTDYGMP6DW083NE6E0DKH2/members\\?type\\='users'  -H \"Authorization: Bearer $TOKEN\" | jq\n{\n  \"limit\": 10,\n  \"total\": 2,\n  \"level\": 0,\n  \"name\": \"\",\n  \"Members\": [\n    {\n      \"ID\": \"5ec9f5f4-5221-43f4-a56f-9594ab110efa\",\n      \"Type\": \"users\"\n    },\n    {\n      \"ID\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n      \"Type\": \"users\"\n    }\n  ]\n}\n</code></pre>"},{"location":"groups/#fetching-from-users-service","title":"Fetching from <code>users</code> service","text":"<pre><code>curl -sSX GET http://localhost/groups/users/01F2TTDYGMP6DW083NE6E0DKH2  -H \"Authorization: Bearer $TOKEN\" | jq        \n{\n  \"total\": 2,\n  \"offset\": 0,\n  \"limit\": 10,\n  \"users\": [\n    {\n      \"id\": \"5ec9f5f4-5221-43f4-a56f-9594ab110efa\",\n      \"email\": \"admin@example.com\"\n    },\n    {\n      \"id\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n      \"email\": \"moko@example.com\"\n    }\n  ]\n}\n</code></pre>"},{"location":"groups/#fetching-from-things-service","title":"Fetching from <code>things</code> service","text":"<pre><code> curl -sSX GET http://localhost/groups/things/01F2TTDYGMP6DW083NE6E0DKH2  -H \"Authorization: Bearer $TOKEN\" | jq\n{\n  \"total\": 2,\n  \"offset\": 0,\n  \"limit\": 10,\n  \"order\": \"\",\n  \"direction\": \"\",\n  \"things\": [\n    {\n      \"id\": \"a0b1d516-67c6-4e8d-8ea2-ad4aff444ca3\",\n      \"key\": \"54dfc44c-3471-4903-a6b5-529dc7a2dd41\"\n    },\n    {\n      \"id\": \"9a036414-5d47-4122-9e58-b3b6953a2097\",\n      \"key\": \"e874fc75-461d-4ece-ac55-2d7cdc10c20a\"\n    }\n  ]\n}\n</code></pre>"},{"location":"groups/#fetching-membership","title":"Fetching membership","text":"<p>For entity that is being put in multiple groups it is possible to retrieve a list of groups it belongs to.</p> <pre><code>curl -sSX GET http://localhost/members/&lt;member_id&gt;/groups  -H \"Authorization: Bearer $TOKEN\" | jq\n{\n  \"total\": 1,\n  \"level\": 0,\n  \"name\": \"\",\n  \"groups\": [\n    {\n      \"id\": \"01F2TTDYGMP6DW083NE6E0DKH2\",\n      \"name\": \"test\",\n      \"owner_id\": \"8e968002-1b19-4e17-bfb6-f0064888a2d1\",\n      \"description\": \"group for test\",\n      \"metadata\": {\n        \"group_attr\": \"attr_value\"\n      },\n      \"level\": 0,\n      \"path\": \"\",\n      \"created_at\": \"0001-01-01T00:00:00Z\",\n      \"updated_at\": \"0001-01-01T00:00:00Z\"\n    }\n  ]\n}\n</code></pre> <ul> <li>member_id - is either thing or user id, or some other enitity if groups are being used for grouping external entities.</li> </ul>"},{"location":"kubernetes/","title":"Kubernetes","text":"<p>Mainflux can be easily deployed on Kubernetes platform by using Helm Chart from official Mainflux DevOps GitHub repository.</p>"},{"location":"kubernetes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes</li> <li>kubectl</li> <li>Helm v3</li> <li>Stable Helm repository</li> <li>Nginx Ingress Controller</li> </ul>"},{"location":"kubernetes/#kubernetes_1","title":"Kubernetes","text":"<p>Kubernetes is an open source container orchestration engine for automating deployment, scaling, and management of containerised applications. Install it locally or have access to a cluster. Follow these instructions if you need more information.</p>"},{"location":"kubernetes/#kubectl","title":"Kubectl","text":"<p>Kubectl is official Kubernetes command line client. Follow these instructions to install it.</p> <p>Regarding the cluster control with <code>kubectl</code>, default config <code>.yaml</code> file should be <code>~/.kube/config</code>.</p>"},{"location":"kubernetes/#helm-v3","title":"Helm v3","text":"<p>Helm is the package manager for Kubernetes. Follow these instructions to install it.</p>"},{"location":"kubernetes/#stable-helm-repository","title":"Stable Helm Repository","text":"<p>Add a stable chart repository:</p> <pre><code>helm repo add stable https://charts.helm.sh/stable\n</code></pre> <p>Add a bitnami chart repository:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\n</code></pre>"},{"location":"kubernetes/#nginx-ingress-controller","title":"Nginx Ingress Controller","text":"<p>Follow these instructions to install it or:</p> <pre><code>helm install ingress-nginx ingress-nginx/ingress-nginx --version 3.26.0 --create-namespace -n ingress-nginx\n</code></pre>"},{"location":"kubernetes/#deploying-mainflux","title":"Deploying Mainflux","text":"<p>Get Helm charts from Mainflux DevOps GitHub repository:</p> <pre><code>git clone https://github.com/mainflux/devops.git\ncd devops/charts/mainflux\n</code></pre> <p>Update the on-disk dependencies to mirror Chart.yaml:</p> <pre><code>helm dependency update\n</code></pre> <p>If you didn't already have namespace created you should do it with:</p> <pre><code>kubectl create namespace mf\n</code></pre> <p>Deploying release named <code>mainflux</code> in namespace named <code>mf</code> is done with just:</p> <pre><code>helm install mainflux . -n mf\n</code></pre> <p>Mainflux is now deployed on your Kubernetes.</p>"},{"location":"kubernetes/#customizing-installation","title":"Customizing Installation","text":"<p>You can override default values while installing with <code>--set</code> option. For example, if you want to specify ingress hostname and pull <code>latest</code> tag of <code>users</code> image:</p> <pre><code>helm install mainflux -n mf --set ingress.hostname='example.com' --set users.image.tag='latest'\n</code></pre> <p>Or if release is already installed, you can update it:</p> <pre><code>helm upgrade mainflux -n mf --set ingress.hostname='example.com' --set users.image.tag='latest'\n</code></pre> <p>The following table lists the configurable parameters and their default values.</p> Parameter Description Default defaults.logLevel Log level debug defaults.image.pullPolicy Docker Image Pull Policy IfNotPresent defaults.image.repository Docker Image Repository mainflux defaults.image.tag Docker Image Tag 0.13.0 defaults.replicaCount Replicas of MQTT adapter, Things, Envoy and Authn 3 defaults.messageBrokerUrl Message broker URL, the default is NATS Url nats://nats:4222 defaults.jaegerPort Jaeger port 6831 nginxInternal.mtls.tls TLS secret which contains the server cert/key nginxInternal.mtls.intermediateCrt Generic secret which contains the intermediate cert used to verify clients ingress.enabled Should the Nginx Ingress be created true ingress.hostname Hostname for the Nginx Ingress ingress.tls.hostname Hostname of the Nginx Ingress certificate ingress.tls.secret TLS secret for the Nginx Ingress messageBroker.maxPayload Maximum payload size in bytes that the Message Broker server, if it is NATS, server will accept 268435456 messageBroker.replicaCount Message Broker replicas 3 authn.dbPort AuthN service DB port 5432 authn.grpcPort AuthN service gRPC port 7001 authn.httpPort AuthN service HTTP port 9020 users.dbPort Users service DB port 5432 users.httpPort Users service HTTP port 9000 things.dbPort Things service DB port 5432 things.httpPort Things service HTTP port 9001 things.authGrpcPort Things service Auth gRPC port 7000 things.authHttpPort Things service Auth HTTP port 9002 things.redisESPort Things service Redis Event Store port 6379 things.redisCachePort Things service Redis Auth Cache port 6379 adapter_http.httpPort HTTP adapter port 8185 mqtt.proxy.mqttPort MQTT adapter proxy port 1884 mqtt.proxy.wsPort MQTT adapter proxy WS port 8081 mqtt.broker.mqttPort MQTT adapter broker port 1883 mqtt.broker.wsPort MQTT adapter broker WS port 8080 mqtt.broker.persistentVolume.size MQTT adapter broker data Persistent Volume size 5Gi mqtt.redisESPort MQTT adapter Event Store port 6379 mqtt.redisCachePort MQTT adapter Redis Auth Cache port 6379 adapter_coap.udpPort CoAP adapter UDP port 5683 ui.port UI port 3000 bootstrap.enabled Enable bootstrap service false bootstrap.dbPort Bootstrap service DB port 5432 bootstrap.httpPort Bootstrap service HTTP port 9013 bootstrap.redisESPort Bootstrap service Redis Event Store port 6379 influxdb.enabled Enable InfluxDB reader &amp; writer false influxdb.dbPort InfluxDB port 8086 influxdb.writer.httpPort InfluxDB writer HTTP port 9006 influxdb.reader.httpPort InfluxDB reader HTTP port 9005 adapter_opcua.enabled Enable OPC-UA adapter false adapter_opcua.httpPort OPC-UA adapter HTTP port 8188 adapter_opcua.redisRouteMapPort OPC-UA adapter Redis Auth Cache port 6379 adapter_lora.enabled Enable LoRa adapter false adapter_lora.httpPort LoRa adapter HTTP port 8187 adapter_lora.redisRouteMapPort LoRa adapter Redis Auth Cache port 6379 twins.enabled Enable twins service false twins.dbPort Twins service DB port 27017 twins.httpPort Twins service HTTP port 9021 twins.redisCachePort Twins service Redis Cache port 6379 <p>All Mainflux services (both core and add-ons) can have their <code>logLevel</code>, <code>image.pullPolicy</code>, <code>image.repository</code> and <code>image.tag</code> overridden.</p> <p>Mainflux Core is a minimalistic set of required Mainflux services. They are all installed by default:</p> <ul> <li>authn</li> <li>users</li> <li>things</li> <li>adapter_http</li> <li>adapter_mqtt</li> <li>adapter_coap</li> <li>ui</li> </ul> <p>Mainflux Add-ons are optional services that are disabled by default. Find in Configuration table parameters for enabling them, i.e. to enable influxdb reader &amp; writer you should run <code>helm install</code> with <code>--set influxdb=true</code>. List of add-ons services in charts:</p> <ul> <li>bootstrap</li> <li>influxdb.writer</li> <li>influxdb.reader</li> <li>adapter_opcua</li> <li>adapter_lora</li> <li>twins</li> </ul> <p>By default scale of MQTT adapter, Things, Envoy, Authn and the Message Broker will be set to 3. It's recommended that you set this values to number of your nodes in Kubernetes cluster, i.e. <code>--set defaults.replicaCount=3 --set messageBroker.replicaCount=3</code></p>"},{"location":"kubernetes/#additional-steps-to-configure-ingress-controller","title":"Additional Steps to Configure Ingress Controller","text":"<p>To send MQTT messages to your host on ports <code>1883</code> and <code>8883</code> some additional steps are required in configuring NGINX Ingress Controller.</p> <p>NGINX Ingress Controller uses ConfigMap to expose TCP and UDP services. That ConfigMaps are included in helm chart in ingress.yaml file assuming that location of ConfigMaps should be <code>ingress-nginx/tcp-services</code> and <code>ingress-nginx/udp-services</code>. These locations was set with <code>--tcp-services-configmap</code> and <code>--udp-services-configmap</code> flags and you can check it in deployment of Ingress Controller or add it there in args section for nginx-ingress-controller if it's not already specified. This is explained in NGINX Ingress documentation</p> <p>Also, these three ports need to be exposed in the Service defined for the Ingress. You can do that with command that edit your service:</p> <p><code>kubectl edit svc -n ingress-nginx nginx-ingress-ingress-nginx-controller</code></p> <p>and add in spec-&gt;ports:</p> <pre><code>  - name: mqtt\n    port: 1883\n    protocol: TCP\n    targetPort: 1883\n  - name: mqtts\n    port: 8883\n    protocol: TCP\n    targetPort: 8883\n  - name: coap\n    port: 5683\n    protocol: UDP\n    targetPort: 5683\n</code></pre>"},{"location":"kubernetes/#tls-mtls","title":"TLS &amp; mTLS","text":"<p>For testing purposes you can generate certificates as explained in detail in authentication chapter of this document. So, you can use this script and after replacing all <code>localhost</code> with your hostname, run:</p> <pre><code>make ca\nmake server_cert\nmake thing_cert KEY=&lt;thing_key&gt;\n</code></pre> <p>you should get in <code>certs</code> folder these certificates that we will use for setting up TLS and mTLS:</p> <pre><code>ca.crt\nca.key\nca.srl\nmainflux-server.crt\nmainflux-server.key\nthing.crt\nthing.key\n</code></pre> <p>Create kubernetes secrets using those certificates with running commands from (secrets script)[https://github.com/mainflux/devops/blob/master/charts/mainflux/secrets/secrets.sh]. In this example secrets are created in <code>mf</code> namespace:</p> <pre><code>kubectl -n mf create secret tls mainflux-server \\\n    --key mainflux-server.key \\\n    --cert mainflux-server.crt\n\nkubectl -n mf create secret generic ca \\\n    --from-file=ca.crt\n</code></pre> <p>You can check if they are succesfully created:  <code>kubectl get secrets -n mf</code></p> <p>And now set ingress.hostname, ingress.tls.hostname to your hostname and ingress.tls.secret to <code>mainflux-server</code> and after helm update you have secured ingress with TLS certificate.</p> <p>For mTLS you need to set <code>nginx_internal.mtls.tls=\"mainflux-server\"</code> and <code>nginx_internal.mtls.intermediate_crt=\"ca\"</code>.</p> <p>Now you can test sending mqtt message with this parameters:</p> <pre><code>mosquitto_pub -d -L mqtts://&lt;thing_id&gt;:&lt;thing_key&gt;@example.com:8883/channels/&lt;channel_id&gt;/messages  --cert  thing.crt --key thing.key --cafile ca.crt  -m \"test-message\"\n</code></pre>"},{"location":"lora/","title":"LoRa","text":"<p>Bridging with LoRaWAN Networks can be done over the lora-adapter. This service sits between Mainflux and LoRa Server and just forwards the messages from one system to another via MQTT protocol, using the adequate MQTT topics and in the good message format (JSON and SenML), i.e. respecting the APIs of both systems.</p> <p>LoRa Server is used for connectivity layer. Specially for the LoRa Gateway Bridge service, which abstracts the SemTech packet-forwarder UDP protocol into JSON over MQTT. But also for the LoRa Server service,  responsible of the de-duplication and handling of uplink frames received by the gateway(s), handling of the LoRaWAN mac-layer and scheduling of downlink data transmissions. Finally the Lora App Server services is used to interact with the system.</p>"},{"location":"lora/#run-lora-server","title":"Run Lora Server","text":"<p>Before to run the <code>lora-adapter</code> you must install and run LoRa Server. First, execute the following command:</p> <pre><code>go get github.com/brocaar/loraserver-docker\n</code></pre> <p>Once everything is installed, execute the following command from the LoRa Server project root:</p> <pre><code>docker-compose up\n</code></pre> <p>Troubleshouting: Mainflux and LoRa Server use their own MQTT brokers which by default occupy MQTT port <code>1883</code>. If both are ran on the same machine different ports must be used. You can fix this on Mainflux side by configuring the environment variable <code>MF_MQTT_ADAPTER_MQTT_PORT</code>.</p>"},{"location":"lora/#setup-lora-server","title":"Setup LoRa Server","text":"<p>Now that both systems are running you must provision LoRa Server, which offers for integration with external services, a RESTful and gRPC API. You can do it as well over the LoRa App Server, which is good example of integration.</p> <ul> <li>Create an Organization: To add your own Gateways to the network you must have an Organization.</li> <li>Create a Network: Set the address of your Network-Server API that is used by LoRa App Server or other custom components interacting with LoRa Server (by default loraserver:8000).</li> <li>Create a Gateways-Profile: In this profile you can select the radio LoRa channels and the LoRa Network Server to use.</li> <li>Create a Service-profile: A service-profile connects an organization to a network-server and defines the features that an organization can use on this Network-Server.</li> <li>Create a Gateway: You must set proper ID in order to be discovered by LoRa Server.</li> <li>Create an Application: This will allows you to create Devices by connecting them to this application. This is equivalent to Devices connected to channels in Mainflux.</li> <li>Create a Device-Profile: Before creating Device you must create Device profile where you will define some parameter as LoRaWAN MAC version (format of the device address) and the LoRaWAN regional parameter (frequency band). This will allow you to create many devices using this profile.</li> <li>Create a Device: Finally, you can create a Device. You must configure the <code>network session key</code> and <code>application session key</code> of your Device. You can generate and copy them on your device configuration or you can use your own pre generated keys and set them using the LoRa App Server UI. Device connect through OTAA. Make sure that loraserver device-profile is using same release as device. If MAC version is 1.0.X, <code>application key = app_key</code> and <code>app_eui = deviceEUI</code>. If MAC version is 1.1 or ABP both parameters will be needed, APP_key and Network key.</li> </ul>"},{"location":"lora/#mainflux-and-lora-server","title":"Mainflux and LoRa Server","text":"<p>Once everything is running and the LoRa Server is provisioned, execute the following command from Mainflux project root to run the lora-adapter:</p> <pre><code>docker-compose -f docker/addons/lora-adapter/docker-compose.yml up -d\n</code></pre> <p>Troubleshouting:  The lora-adapter subscribes to the LoRa Server MQTT broker and will fail if the connection is not established. You must ensure that the environment variable <code>MF_LORA_ADAPTER_MESSAGES_URL</code> is propertly configured.</p> <p>Remark: By defaut, <code>MF_LORA_ADAPTER_MESSAGES_URL</code> is set as <code>tcp://lora.mqtt.mainflux.io:1883</code> in the docker-compose.yml file of the adapter. If you run the composition without configure this variable you will start to receive messages from our demo server.</p>"},{"location":"lora/#route-map","title":"Route Map","text":"<p>The lora-adapter use Redis database to create a route map between both systems. As in Mainflux we use Channels to connect Things, LoRa Server uses Applications to connect Devices.</p> <p>The lora-adapter uses the matadata of provision events emitted by Mainflux system to update his route map. For that, you must provision Mainflux Channels and Things with an extra metadata key in the JSON Body of the HTTP request. It must be a JSON object with key <code>lora</code> which value is another JSON object. This nested JSON object should contain <code>app_id</code> or <code>dev_eui</code> field. In this case <code>app_id</code> or <code>dev_eui</code> must be an existent Lora application ID or device EUI:</p> <p>Channel structure:</p> <pre><code>{\n  \"name\": \"&lt;channel name&gt;\",\n  \"metadata:\": {\n    \"lora\": {\n      \"app_id\": \"&lt;application ID&gt;\"\n    }\n  }\n}\n</code></pre> <p>Thing structure:</p> <pre><code>{\n  \"type\": \"device\",\n  \"name\": \"&lt;thing name&gt;\",\n  \"metadata:\": {\n    \"lora\": {\n      \"dev_eui\": \"&lt;device EUI&gt;\"\n    }\n  }\n}\n</code></pre>"},{"location":"lora/#messaging","title":"Messaging","text":"<p>To forward LoRa messages the lora-adapter subscribes to topics <code>applications/+/devices/+</code> of the LoRa Server MQTT broker. It verifies the <code>app_id</code> and the <code>dev_eui</code> of received messages. If the mapping exists it uses corresponding <code>Channel ID</code> and <code>Thing ID</code> to sign and forwards the content of the LoRa message to the Mainflux message broker.</p>"},{"location":"messaging/","title":"Messaging","text":"<p>Once a channel is provisioned and thing is connected to it, it can start to publish messages on the channel. The following sections will provide an example of message publishing for each of the supported protocols.</p>"},{"location":"messaging/#http","title":"HTTP","text":"<p>To publish message over channel, thing should send following request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/senml+json\" -H \"Authorization: Thing &lt;thing_key&gt;\" https://localhost/http/channels/&lt;channel_id&gt;/messages -d '[{\"bn\":\"some-base-name:\",\"bt\":1.276020076001e+09, \"bu\":\"A\",\"bver\":5, \"n\":\"voltage\",\"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"t\":-5,\"v\":1.2}, {\"n\":\"current\",\"t\":-4,\"v\":1.3}]'\n</code></pre> <p>Note that if you're going to use senml message format, you should always send messages as an array.</p> <p>For more information about the HTTP messaging service API, please check out the API documentation.</p>"},{"location":"messaging/#mqtt","title":"MQTT","text":"<p>To send and receive messages over MQTT you could use Mosquitto tools, or Paho if you want to use MQTT over WebSocket.</p> <p>To publish message over channel, thing should call following command:</p> <pre><code>mosquitto_pub -u &lt;thing_id&gt; -P &lt;thing_key&gt; -t channels/&lt;channel_id&gt;/messages -h localhost -m '[{\"bn\":\"some-base-name:\",\"bt\":1.276020076001e+09, \"bu\":\"A\",\"bver\":5, \"n\":\"voltage\",\"u\":\"V\",\"v\":120.1}, {\"n\":\"current\",\"t\":-5,\"v\":1.2}, {\"n\":\"current\",\"t\":-4,\"v\":1.3}]'\n</code></pre> <p>To subscribe to channel, thing should call following command:</p> <pre><code>mosquitto_sub -u &lt;thing_id&gt; -P &lt;thing_key&gt; -t channels/&lt;channel_id&gt;/messages -h localhost\n</code></pre> <p>If you want to use standard topic such as <code>channels/&lt;channel_id&gt;/messages</code> with SenML content type (JSON or CBOR), you should use following topic <code>channels/&lt;channel_id&gt;/messages</code>.</p> <p>If you are using TLS to secure MQTT connection, add <code>--cafile docker/ssl/certs/ca.crt</code> to every command.</p>"},{"location":"messaging/#coap","title":"CoAP","text":"<p>CoAP adapter implements CoAP protocol using underlying UDP and according to RFC 7252. To send and receive messages over CoAP, you can use CoAP CLI. To set the add-on, please follow the installation instructions provided here.</p>"},{"location":"messaging/#_1","title":"Messaging","text":"<p>Examples:</p> <pre><code>coap-cli get channels/0bb5ba61-a66e-4972-bab6-26f19962678f/messages/subtopic -auth 1e1017e6-dee7-45b4-8a13-00e6afeb66eb -o\n</code></pre> <pre><code>coap-cli post channels/0bb5ba61-a66e-4972-bab6-26f19962678f/messages/subtopic -auth 1e1017e6-dee7-45b4-8a13-00e6afeb66eb -d \"hello world\"\n</code></pre> <pre><code>coap-cli post channels/0bb5ba61-a66e-4972-bab6-26f19962678f/messages/subtopic -auth 1e1017e6-dee7-45b4-8a13-00e6afeb66eb -d \"hello world\" -h 0.0.0.0 -p 1234\n</code></pre> <p>To send a message, use <code>POST</code> request. To subscribe, send <code>GET</code> request with Observe option (flag <code>o</code>) set to false. There are two ways to unsubscribe:   1) Send <code>GET</code> request with Observe option set to true.   2) Forget the token and send <code>RST</code> message as a response to <code>CONF</code> message received by the server.</p> <p>The most of the notifications received from the Adapter are non-confirmable. By RFC 7641:</p> <p>Server must send a notification in a confirmable message instead of a non-confirmable message at least every 24 hours. This prevents a client that went away or is no longer interested from remaining in the list of observers indefinitely.</p> <p>CoAP Adapter sends these notifications every 12 hours. To configure this period, please check adapter documentation If the client is no longer interested in receiving notifications, the second scenario described above can be used to unsubscribe.</p>"},{"location":"messaging/#websocket","title":"WebSocket","text":"<p>To publish and receive messages over channel using web socket, you should first send handshake request to <code>/channels/&lt;channel_id&gt;/messages</code> path. Don't forget to send <code>Authorization</code> header with thing authorization token. In order to pass message content type to WS adapter you can use <code>Content-Type</code> header.</p> <p>If you are not able to send custom headers in your handshake request, send them as query parameter <code>authorization</code> and <code>content-type</code>. Then your path should look like this <code>/channels/&lt;channel_id&gt;/messages?authorization=&lt;thing_auth_key&gt;&amp;content-type=&lt;content-type&gt;</code>.</p> <p>If you are using the docker environment prepend the url with <code>ws</code>. So for example <code>/ws/channels/&lt;channel_id&gt;/messages?authorization=&lt;thing_auth_key&gt;&amp;content-type=&lt;content-type&gt;</code>.</p>"},{"location":"messaging/#basic-nodejs-example","title":"Basic nodejs example","text":"<pre><code>const WebSocket = require('ws');\n// do not verify self-signed certificates if you are using one\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'\n// c02ff576-ccd5-40f6-ba5f-c85377aad529 is an example of a thing_auth_key\nconst ws = new WebSocket('ws://localhost:8186/ws/channels/1/messages?authorization=c02ff576-ccd5-40f6-ba5f-c85377aad529')\nws.on('open', () =&gt; {\n    ws.send('something')\n})\nws.on('message', (data) =&gt; {\n    console.log(data)\n})\nws.on('error', (e) =&gt; {\n    console.log(e)\n})\n</code></pre>"},{"location":"messaging/#basic-golang-example","title":"Basic golang example","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"os/signal\"\n    \"time\"\n\n    \"github.com/gorilla/websocket\"\n)\n\nvar done chan interface{}\nvar interrupt chan os.Signal\n\nfunc receiveHandler(connection *websocket.Conn) {\n    defer close(done)\n\n    for {\n        _, msg, err := connection.ReadMessage()\n        if err != nil {\n            log.Fatal(\"Error in receive: \", err)\n            return\n        }\n\n        log.Printf(\"Received: %s\\n\", msg)\n    }\n}\n\nfunc main() {\n    done = make(chan interface{})\n    interrupt = make(chan os.Signal)\n\n    signal.Notify(interrupt, os.Interrupt)\n\n    channelId := \"30315311-56ba-484d-b500-c1e08305511f\"\n    thingKey := \"c02ff576-ccd5-40f6-ba5f-c85377aad529\"\n\n    socketUrl := \"ws://localhost:8186/channels/\" + channelId + \"/messages/?authorization=\" + thingKey\n\n    conn, _, err := websocket.DefaultDialer.Dial(socketUrl, nil)\n    if err != nil {\n        log.Fatal(\"Error connecting to Websocket Server: \", err)\n    } else {\n        log.Println(\"Connected to the ws adapter\")\n    }\n    defer conn.Close()\n\n    go receiveHandler(conn)\n\n    for {\n        select {\n\n        case &lt;-interrupt:\n            log.Println(\"Interrupt occured, closing the connection...\")\n            conn.Close()\n            err := conn.WriteMessage(websocket.TextMessage, []byte(\"closed this ws client just now\"))\n            if err != nil {\n                log.Println(\"Error during closing websocket: \", err)\n                return\n            }\n\n            select {\n            case &lt;-done:\n                log.Println(\"Receiver Channel Closed! Exiting...\")\n\n            case &lt;-time.After(time.Duration(1) * time.Second):\n                log.Println(\"Timeout in closing receiving channel. Exiting...\")\n            }\n            return\n        }\n    }\n}\n\n</code></pre>"},{"location":"messaging/#mqtt-over-ws","title":"MQTT-over-WS","text":"<p>Mainflux also supports MQTT-over-WS, along with pure WS protocol. this bring numerous benefits for IoT applications that are derived from the properties of MQTT - like QoS and PUB/SUB features.</p> <p>There are 2 reccomended Javascript libraries for implementing browser support for Mainflux MQTT-over-WS connectivity:</p> <ol> <li>Eclipse Paho JavaScript Client</li> <li>MQTT.js</li> </ol> <p>As WS is an extension of HTTP protocol, Mainflux exposes it on port <code>8008</code>, so it's usage is practically transparent. Additionally, please notice that since same port as for HTTP is used (<code>8008</code>), and extension URL <code>/mqtt</code> should be used - i.e. connection URL should be <code>ws://&lt;host_addr&gt;/mqtt</code>.</p> <p>For quick testing you can use HiveMQ UI tool.</p> <p>Here is an example of a browser application connecting to Mainflux server and sending and receiving messages over WebSocket using MQTT.js library:</p> <pre><code>&lt;script src=\"https://unpkg.com/mqtt/dist/mqtt.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n    // Initialize a mqtt variable globally\n    console.log(mqtt)\n\n    // connection option\n    const options = {\n        clean: true, // retain session\n        connectTimeout: 4000, // Timeout period\n        // Authentication information\n        clientId: '14d6c682-fb5a-4d28-b670-ee565ab5866c',\n        username: '14d6c682-fb5a-4d28-b670-ee565ab5866c',\n        password: 'ec82f341-d4b5-4c77-ae05-34877a62428f',\n    }\n\n    var channelId = '08676a76-101d-439c-b62e-d4bb3b014337'\n    var topic = 'channels/' + channelId + '/messages'\n\n    // Connect string, and specify the connection method by the protocol\n    // ws Unencrypted WebSocket connection\n    // wss Encrypted WebSocket connection\n    const connectUrl = 'ws://localhost/mqtt'\n    const client = mqtt.connect(connectUrl, options)\n\n    client.on('reconnect', (error) =&gt; {\n        console.log('reconnecting:', error)\n    })\n\n    client.on('error', (error) =&gt; {\n        console.log('Connection failed:', error)\n    })\n\n    client.on('connect', function () {\n        console.log('client connected:' + options.clientId)\n        client.subscribe(topic, { qos: 0 })\n        client.publish(topic, 'WS connection demo!', { qos: 0, retain: false })\n    })\n\n    client.on('message', function (topic, message, packet) {\n        console.log('Received Message:= ' + message.toString() + '\\nOn topic:= ' + topic)\n    })\n\n    client.on('close', function () {\n        console.log(options.clientId + ' disconnected')\n    })\n&lt;/script&gt;\n</code></pre> <p>N.B. Eclipse Paho lib adds sub-URL <code>/mqtt</code> automaticlly, so procedure for connecting to the server can be something like this:</p> <pre><code>var loc = { hostname: 'localhost', port: 8008 }\n// Create a client instance\nclient = new Paho.MQTT.Client(loc.hostname, Number(loc.port), \"clientId\")\n// Connect the client\nclient.connect({onSuccess:onConnect});\n</code></pre>"},{"location":"messaging/#subtopics","title":"Subtopics","text":"<p>In order to use subtopics and give more meaning to your pub/sub channel, you can simply add any suffix to base <code>/channels/&lt;channel_id&gt;/messages</code> topic.</p> <p>Example subtopic publish/subscribe for bedroom temperature would be <code>channels/&lt;channel_id&gt;/messages/bedroom/temperature</code>.</p> <p>Subtopics are generic and multilevel. You can use almost any suffix with any depth.</p> <p>Topics with subtopics are propagated to Message broker in the following format <code>channels.&lt;channel_id&gt;.&lt;optional_subtopic&gt;</code>.</p> <p>Our example topic <code>channels/&lt;channel_id&gt;/messages/bedroom/temperature</code> will be translated to appropriate Message Broker topic <code>channels.&lt;channel_id&gt;.bedroom.temperature</code>.</p> <p>You can use multilevel subtopics, that have multiple parts. These parts are separated by <code>.</code> or <code>/</code> separators. When you use combination of these two, have in mind that behind the scene, <code>/</code> separator will be replaced with <code>.</code>. Every empty part of subtopic will be removed. What this means is that subtopic <code>a///b</code> is equivalent to <code>a/b</code>. When you want to subscribe, you can use the default Message Broker, NATS, wildcards <code>*</code> and <code>&gt;</code>. Every subtopic part can have <code>*</code> or <code>&gt;</code> as it's value, but if there is any other character beside these wildcards, subtopic will be invalid. What this means is that subtopics such as <code>a.b*c.d</code> will be invalid, while <code>a.b.*.c.d</code> will be valid.</p> <p>Authorization is done on channel level, so you only have to have access to channel in order to have access to it's subtopics.</p> <p>Note: When using MQTT, it's recommended that you use standard MQTT wildcards <code>+</code> and <code>#</code>.</p> <p>For more information and examples checkout official nats.io documentation, official rabbitmq documentation, official vernemq documentation and official kafka documentation</p>"},{"location":"opcua/","title":"OPC-UA","text":"<p>Bridging with an OPC-UA Server can be done over the opcua-adapter. This service sits between Mainflux and an OPC-UA Server and just forwards the messages from one system to another.</p>"},{"location":"opcua/#run-opc-ua-server","title":"Run OPC-UA Server","text":"<p>The OPC-UA Server is used for connectivity layer. It allows various methods to read information from the OPC-UA server and its nodes. The current version of the opcua-adapter still experimental and only <code>Browse</code> and <code>Subscribe</code> methods are implemented. Public OPC-UA test servers are available for testing of OPC-UA clients and can be used for development and test purposes.</p>"},{"location":"opcua/#mainflux-opc-ua-adapter","title":"Mainflux OPC-UA Adapter","text":"<p>Execute the following command from Mainflux project root to run the opcua-adapter:</p> <pre><code>docker-compose -f docker/addons/opcua-adapter/docker-compose.yml up -d\n</code></pre>"},{"location":"opcua/#route-map","title":"Route Map","text":"<p>The opcua-adapter use Redis database to create a route-map between Mainflux and an OPC-UA Server. As Mainflux use Things and Channels IDs to sign messages, OPC-UA use node ID (node namespace and node identifier combination) and server URI. The adapter route-map associate a <code>Thing ID</code> with a <code>Node ID</code> and a <code>Channel ID</code> with a <code>Server URI</code>.</p> <p>The opcua-adapter uses the matadata of provision events emitted by Mainflux system to update its route map. For that, you must provision Mainflux Channels and Things with an extra metadata key in the JSON Body of the HTTP request. It must be a JSON object with key <code>opcua</code> which value is another JSON object. This nested JSON object should contain <code>node_id</code> or <code>server_uri</code> that correspond to an existent OPC-UA <code>Node ID</code> or <code>Server URI</code>:</p> <p>Channel structure:</p> <pre><code>{\n  \"name\": \"&lt;channel name&gt;\",\n  \"metadata:\": {\n    \"opcua\": {\n      \"server_uri\": \"&lt;Server URI&gt;\"\n    }\n  }\n}\n</code></pre> <p>Thing structure:</p> <pre><code>{\n  \"name\": \"&lt;thing name&gt;\",\n  \"metadata:\": {\n    \"opcua\": {\n      \"node_id\": \"&lt;Node ID&gt;\",\n    }\n  }\n}\n</code></pre>"},{"location":"opcua/#browse","title":"Browse","text":"<p>The opcua-adapter exposes a <code>/browse</code> HTTP endpoint accessible with method <code>GET</code> and configurable throw HTTP query parameters <code>server</code>, <code>namespace</code> and <code>identifier</code>. The server URI, the node namespace and the node identifier represent the parent node and are used to fetch the list of available children nodes starting from the given one. By default the root node ID (node namespace and node identifier combination) of an OPC-UA server is <code>ns=0;i=84</code>. It's also the default value used by the opcua-adapter to do the browsing if only the server URI is specified in the HTTP query.</p>"},{"location":"opcua/#subscribe","title":"Subscribe","text":"<p>To create an OPC-UA subscription, user should connect the Thing to the Channel. This will automatically create the connection, enable the redis route-map and run a subscription to the <code>server_uri</code> and <code>node_id</code> defined in the Thing and Channel metadata.</p>"},{"location":"opcua/#messaging","title":"Messaging","text":"<p>To forward OPC-UA messages the opcua-adapter subscribes to the Node ID of an OPC-UA Server URI. It verifies the <code>server_uri</code> and the <code>node_id</code> of received messages. If the mapping exists it uses corresponding <code>Channel ID</code> and <code>Thing ID</code> to sign and forwards the content of the OPC-UA message to the Mainflux message broker. If the mapping or the connection between the Thing and the Channel don't exist the subscription stops.</p>"},{"location":"provision/","title":"Provision","text":"<p>Provisioning is a process of configuration of an IoT platform in which system operator creates and sets-up different entities used in the platform - users, channels and things.</p>"},{"location":"provision/#platform-management","title":"Platform management","text":""},{"location":"provision/#users-management","title":"Users Management","text":""},{"location":"provision/#account-creation","title":"Account Creation","text":"<p>Use the Mainflux API to create user account:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/json\" https://localhost/users -d '{\"email\":\"john.doe@email.com\", \"password\":\"12345678\"}'\n</code></pre> <p>Note that when using official <code>docker-compose</code>, all services are behind <code>nginx</code> proxy and all traffic is <code>TLS</code> encrypted.</p>"},{"location":"provision/#obtaining-an-authorization-key","title":"Obtaining an Authorization Key","text":"<p>In order for this user to be able to authenticate to the system, you will have to create an authorization token for him:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/json\" https://localhost/tokens -d '{\"email\":\"john.doe@email.com\", \"password\":\"12345678\"}'\n</code></pre> <p>Response should look like this:</p> <pre><code>{\n      \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MjMzODg0NzcsImlhdCI6MTUyMzM1MjQ3NywiaXNzIjoibWFpbmZsdXgiLCJzdWIiOiJqb2huLmRvZUBlbWFpbC5jb20ifQ.cygz9zoqD7Rd8f88hpQNilTCAS1DrLLgLg4PRcH-iAI\"\n}\n</code></pre> <p>For more information about the Users service API, please check out the API documentation.</p>"},{"location":"provision/#system-provisioning","title":"System Provisioning","text":"<p>Before proceeding, make sure that you have created a new account and obtained an authorization key.</p>"},{"location":"provision/#provisioning-things","title":"Provisioning Things","text":"<p>This endpoint will be depreciated in 0.11.0.  It will be replaced with the bulk endpoint currently found at /things/bulk.</p> <p>Things are created by executing request <code>POST /things</code> with a JSON payload. Note that you will also need <code>user_token</code> in order to create things that belong to this particular user.</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things -d '{\"name\":\"weio\"}'\n</code></pre> <p>Response will contain <code>Location</code> header whose value represents path to newly created thing:</p> <pre><code>HTTP/1.1 201 Created\nContent-Type: application/json\nLocation: /things/81380742-7116-4f6f-9800-14fe464f6773\nDate: Tue, 10 Apr 2018 10:02:59 GMT\nContent-Length: 0\n</code></pre>"},{"location":"provision/#bulk-provisioning-things","title":"Bulk Provisioning Things","text":"<p>Multiple things can be created by executing a <code>POST /things/bulk</code> request with a JSON payload.  The payload should contain a JSON array of the things to be created.  If there is an error any of the things, none of the things will be created.</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things/bulk -d '[{\"name\":\"weio\"},{\"name\":\"bob\"}]'\n</code></pre> <p>The response's body will contain a list of the created things.</p> <pre><code>HTTP/2 201\nserver: nginx/1.16.0\ndate: Tue, 22 Oct 2019 02:19:15 GMT\ncontent-type: application/json\ncontent-length: 222\naccess-control-expose-headers: Location\n\n{\"things\":[{\"id\":\"8909adbf-312f-41eb-8cfc-ccc8c4e3655e\",\"name\":\"weio\",\"key\":\"4ef103cc-964a-41b5-b75b-b7415c3a3619\"},{\"id\":\"2fcd2349-38f7-4b5c-8a29-9607b2ca8ff5\",\"name\":\"bob\",\"key\":\"ff0d1490-355c-4dcf-b322-a4c536c8c3bf\"}]}\n</code></pre>"},{"location":"provision/#retrieving-provisioned-things","title":"Retrieving Provisioned Things","text":"<p>In order to retrieve data of provisioned things that is written in database, you can send following request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things\n</code></pre> <p>Notice that you will receive only those things that were provisioned by <code>user_token</code> owner.</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nDate: Tue, 10 Apr 2018 10:50:12 GMT\nContent-Length: 1105\n\n{\n  \"total\": 2,\n  \"offset\": 0,\n  \"limit\": 10,\n  \"things\": [\n    {\n      \"id\": \"81380742-7116-4f6f-9800-14fe464f6773\",\n      \"name\": \"weio\",\n      \"key\": \"7aa91f7a-cbea-4fed-b427-07e029577590\"\n    },\n    {\n      \"id\": \"cb63f852-2d48-44f0-a0cf-e450496c6c92\",\n      \"name\": \"myapp\",\n      \"key\": \"cbf02d60-72f2-4180-9f82-2c957db929d1\"\n    }\n  ]\n}\n</code></pre> <p>You can specify <code>offset</code> and <code>limit</code> parameters in order to fetch a specific group of things. In that case, your request should look like:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things?offset=0&amp;limit=5\n</code></pre> <p>You can specify <code>name</code> and/or <code>metadata</code> parameters in order to fetch specific group of things. When specifying metadata you can specify just a part of the metadata JSON you want to match.</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things?offset=0&amp;limit=5&amp;metadata=\"\\{\\\"serial\\\":\\\"123456\\\"\\}\"\n</code></pre> <p>If you don't provide them, default values will be used instead: 0 for <code>offset</code> and 10 for <code>limit</code>. Note that <code>limit</code> cannot be set to values greater than 100. Providing invalid values will be considered malformed request.</p>"},{"location":"provision/#searching-provisioned-things","title":"Searching Provisioned Things","text":"<p>In order to search things with specific name and/or metadata, you can send following request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things/search -d '{\"metadata\":{\"foo\":\"bar\"}, \"name\":\"bob\", \"limit\": 10, \"offset\":0, \"order\":\"name\", \"dir\":\"desc\"}'\n</code></pre> <p>You can specify <code>offset</code> and <code>limit</code> parameters in order to fetch a specific set of things. Also, you can specify ordering with direction through parameters <code>order</code> and <code>dir</code>. Ordering values can be <code>name</code> or <code>id</code> of things, order direction can be <code>asc</code> or <code>desc</code>. If you don't provide them, default values will be used instead: 0 for <code>offset</code> and 10 for <code>limit</code>. Note that <code>limit</code> cannot be set to values greater than 100. Providing invalid values will be considered malformed request.</p> <p>The response's body will contain a list of the things filtered by name and/or metadata:</p> <pre><code>HTTP/2 200\nserver: nginx/1.16.0\ndate: Mon, 15 Mar 2021 18:34:10 GMT\ncontent-type: application/json\ncontent-length: 208\naccess-control-expose-headers: Location\n\n{\n  \"total\": 1,\n  \"offset\": 0,\n  \"limit\": 10,\n  \"order\": \"name\",\n  \"direction\": \"desc\",\n  \"things\": [\n    {\n      \"id\": \"1b86eea5-94b6-41fa-be9f-d10c85a8994d\",\n      \"name\": \"bob\",\n      \"key\": \"d72de10f-4963-4bf1-a454-874a39bb498e\",\n      \"metadata\": {\n        \"foo\": \"bar\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"provision/#removing-things","title":"Removing Things","text":"<p>In order to remove you own thing you can send following request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X DELETE -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things/&lt;thing_id&gt;\n</code></pre>"},{"location":"provision/#provisioning-channels","title":"Provisioning Channels","text":"<p>This endpoint will be depreciated in 0.11.0.  It will be replaced with the bulk endpoint currently found at /channels/bulk.</p> <p>Channels are created by executing request <code>POST /channels</code>:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels -d '{\"name\":\"mychan\"}'\n</code></pre> <p>After sending request you should receive response with <code>Location</code> header that contains path to newly created channel:</p> <pre><code>HTTP/1.1 201 Created\nContent-Type: application/json\nLocation: /channels/19daa7a8-a489-4571-8714-ef1a214ed914\nDate: Tue, 10 Apr 2018 11:30:07 GMT\nContent-Length: 0\n</code></pre>"},{"location":"provision/#bulk-provisioning-channels","title":"Bulk Provisioning Channels","text":"<p>Multiple channels can be created by executing a <code>POST /things/bulk</code> request with a JSON payload.  The payload should contain a JSON array of the channels to be created.  If there is an error any of the channels, none of the channels will be created.</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels/bulk -d '[{\"name\":\"joe\"},{\"name\":\"betty\"}]'\n</code></pre> <p>The response's body will contain a list of the created channels.</p> <pre><code>HTTP/2 201\nserver: nginx/1.16.0\ndate: Tue, 22 Oct 2019 02:14:41 GMT\ncontent-type: application/json\ncontent-length: 135\naccess-control-expose-headers: Location\n\n{\"channels\":[{\"id\":\"5a21bbcb-4c9a-4bb4-af31-9982d00f7a6e\",\"name\":\"joe\"},{\"id\":\"d74b119b-2eea-4285-a999-9f747869bb45\",\"name\":\"betty\"}]}\n</code></pre>"},{"location":"provision/#retrieving-provisioned-channels","title":"Retrieving Provisioned Channels","text":"<p>To retreve provisioned channels you should send request to <code>/channels</code> with authorization token in <code>Authorization</code> header:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels\n</code></pre> <p>Note that you will receive only those channels that were created by authorization token's owner.</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nDate: Tue, 10 Apr 2018 11:38:06 GMT\nContent-Length: 139\n\n{\n  \"total\": 1,\n  \"offset\": 0,\n  \"limit\": 10,\n  \"channels\": [\n    {\n      \"id\": \"19daa7a8-a489-4571-8714-ef1a214ed914\",\n      \"name\": \"mychan\"\n    }\n  ]\n}\n</code></pre> <p>You can specify  <code>offset</code> and  <code>limit</code> parameters in order to fetch specific group of channels. In that case, your request should look like:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels?offset=0&amp;limit=5\n</code></pre> <p>If you don't provide them, default values will be used instead: 0 for <code>offset</code> and 10 for <code>limit</code>. Note that <code>limit</code> cannot be set to values greater than 100. Providing invalid values will be considered malformed request.</p>"},{"location":"provision/#removing-channels","title":"Removing Channels","text":"<p>In order to remove specific channel you should send following request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X DELETE -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels/&lt;channel_id&gt;\n</code></pre>"},{"location":"provision/#access-control","title":"Access Control","text":"<p>Channel can be observed as a communication group of things. Only things that are connected to the channel can send and receive messages from other things in this channel. Things that are not connected to this channel are not allowed to communicate over it.</p> <p>Only user, who is the owner of a channel and of the things, can connect the things to the channel (which is equivalent of giving permissions to these things to communicate over given communication group).</p> <p>To connect a thing to the channel you should send following request:</p> <p>This endpoint will be depreciated in 0.11.0.  It will be replaced with the bulk endpoint found at /connect.</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X PUT -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels/&lt;channel_id&gt;/things/&lt;thing_id&gt;\n</code></pre> <p>To connect multiple things to a channel, you can send the following request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/connect -d '{\"channel_ids\":[\"&lt;channel_id&gt;\", \"&lt;channel_id&gt;\"],\"thing_ids\":[\"&lt;thing_id&gt;\", \"&lt;thing_id&gt;\"]}'\n</code></pre> <p>You can observe which things are connected to specific channel:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels/&lt;channel_id&gt;/things\n</code></pre> <p>You can also observe which things are not connected to specific channel by adding a query parameter <code>connected=false</code> to the HTTP request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels/&lt;channel_id&gt;/things?connected=false\n</code></pre> <p>Response that you'll get should look like this:</p> <pre><code>{\n  \"total\": 2,\n  \"offset\": 0,\n  \"limit\": 10,\n  \"things\": [\n    {\n      \"id\": \"3ffb3880-d1e6-4edd-acd9-4294d013f35b\",\n      \"name\": \"d0\",\n      \"key\": \"b1996995-237a-4552-94b2-83ec2e92a040\",\n      \"metadata\": \"{}\"\n    },\n    {\n      \"id\": \"94d166d6-6477-43dc-93b7-5c3707dbef1e\",\n      \"name\": \"d1\",\n      \"key\": \"e4588a68-6028-4740-9f12-c356796aebe8\",\n      \"metadata\": \"{}\"\n    }\n  ]\n}\n</code></pre> <p>You can observe to which channels is specified thing connected:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things/&lt;thing_id&gt;/channels\n</code></pre> <p>You can also observe to which channels is specified thing not connected by adding a query parameter <code>connected=false</code> to the HTTP request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/things/&lt;thing_id&gt;/channels?connected=false\n</code></pre> <p>Response that you'll get should look like this:</p> <pre><code>{\n  \"total\": 2,\n  \"offset\": 0,\n  \"limit\": 10,\n  \"channels\": [\n    {\n      \"id\": \"5e62eb13-2695-4860-8d87-85b8a2f80fd4\",\n      \"name\": \"c1\",\n      \"metadata\": \"{}\"\n    },\n    {\n      \"id\": \"c4b5e19a-7ffe-4172-b2c5-c8b9d570a165\",\n      \"name\": \"c0\",\n      \"metadata\":\"{}\"\n    }\n  ]\n}\n</code></pre> <p>If you want to disconnect your thing from the channel, send following request:</p> <pre><code>curl -s -S -i --cacert docker/ssl/certs/ca.crt -X DELETE -H \"Authorization: Bearer &lt;user_token&gt;\" https://localhost/channels/&lt;channel_id&gt;/things/&lt;thing_id&gt;\n</code></pre> <p>For more information about the Things service API, please check out the API documentation.</p>"},{"location":"provision/#provision-service","title":"Provision Service","text":"<p>Provisioning is a process of configuration of an IoT platform in which system operator creates and sets-up different entities used in the platform - users, channels and things. It is part of process of setting up IoT applications where we connect devices on edge with platform in cloud.</p> <p>For provisioning we can use Mainflux CLI for creating users and for each node in the edge (eg. gateway) required number of things, channels, connecting them and creating certificates if needed.</p> <p>Provision service is used to set up initial application configuration once user is created. Provision service creates  things, channels, connections and certificates. Once user is created we can use provision to create a setup for edge node in one HTTP request instead of issuing several CLI commands.</p> <p>Provision service provides an HTTP API to interact with Mainflux.</p> <p>For gateways to communicate with Mainflux configuration is required (MQTT host, thing, channels, certificates...). Gateway will send a request to Bootstrap service providing <code>&lt;external_id&gt;</code> and <code>&lt;external_key&gt;</code> in HTTP request to get the configuration. To make a request to Bootstrap service you can use Agent service on a gateway.</p> <p>To create bootstrap configuration you can use Bootstrap or <code>Provision</code> service. Mainflux UI uses Bootstrap service for creating gateway configurations. <code>Provision</code> service should provide an easy way of provisioning your gateways i.e creating bootstrap configuration and as many things and channels that your setup requires.</p> <p>Also, you may use provision service to create certificates for each thing. Each service running on gateway may require more than one thing and channel for communication. If, for example, you are using services Agent and Export on a gateway you will need two channels for <code>Agent</code> (<code>data</code> and <code>control</code>) and one thing for <code>Export</code>. Additionally, if you enabled mTLS each service will need its own thing and certificate for access to Mainflux. Your setup could require any number of things and channels, this kind of setup we can call <code>provision layout</code>.</p> <p>Provision service provides a way of specifying this <code>provision layout</code> and creating a setup according to that layout by serving requests on <code>/mapping</code> endpoint. Provision layout is configured in config.toml.</p>"},{"location":"provision/#configuration","title":"Configuration","text":"<p>The service is configured using the environment variables presented in the following table. Note that any unset variables will be replaced with their default values.</p> <p>By default, call to <code>/mapping</code> endpoint will create one thing and two channels (<code>control</code> and <code>data</code>) and connect it as this is typical setup required by Agent. If there is a requirement for different provision layout we can use config file in addition to environment variables.</p> <p>For the purposes of running provision as an add-on in docker composition environment variables seems more suitable. Environment variables are set in .env.</p> <p>Configuration can be specified in config.toml. Config file can specify all the settings that environment variables can configure and in addition <code>/mapping</code> endpoint provision layout can be configured.</p> <p>In <code>config.toml</code> we can enlist an array of things and channels that we want to create and make connections between them which we call provision layout.</p> <p>Things Metadata can be whatever suits your needs. Thing that has metadata with <code>external_id</code> will have bootstrap configuration created, <code>external_id</code> value will be populated with value from request). Bootstrap configuration can be fetched with Agent. For channel's metadata <code>type</code> is reserved for <code>control</code> and <code>data</code> which we use with Agent.</p> <p>Example of provision layout below</p> <pre><code>[bootstrap]\n  [bootstrap.content]\n    [bootstrap.content.agent.edgex]\n      url = \"http://localhost:48090/api/v1/\"\n\n    [bootstrap.content.agent.log]\n      level = \"info\"\n\n    [bootstrap.content.agent.mqtt]\n      mtls = false\n      qos = 0\n      retain = false\n      skip_tls_ver = true\n      url = \"localhost:1883\"\n\n    [bootstrap.content.agent.server]\n      nats_url = \"localhost:4222\"\n      port = \"9000\"\n\n    [bootstrap.content.agent.heartbeat]\n      interval = \"30s\"\n\n    [bootstrap.content.agent.terminal]\n      session_timeout = \"30s\"\n\n    [bootstrap.content.export.exp]\n      log_level = \"debug\"\n      nats = \"nats://localhost:4222\"\n      port = \"8172\"\n      cache_url = \"localhost:6379\"\n      cache_pass = \"\"\n      cache_db = \"0\"\n\n    [bootstrap.content.export.mqtt]\n      ca_path = \"ca.crt\"\n      cert_path = \"thing.crt\"\n      channel = \"\"\n      host = \"tcp://localhost:1883\"\n      mtls = false\n      password = \"\"\n      priv_key_path = \"thing.key\"\n      qos = 0\n      retain = false\n      skip_tls_ver = false\n      username = \"\"\n\n    [[bootstrap.content.export.routes]]\n      mqtt_topic = \"\"\n      nats_topic = \"channels\"\n      subtopic = \"\"\n      type = \"mfx\"\n      workers = 10\n\n    [[bootstrap.content.export.routes]]\n      mqtt_topic = \"\"\n      nats_topic = \"export\"\n      subtopic = \"\"\n      type = \"default\"\n      workers = 10\n\n[[things]]\n  name = \"thing\"\n\n  [things.metadata]\n    external_id = \"xxxxxx\"\n\n[[channels]]\n  name = \"control-channel\"\n\n  [channels.metadata]\n    type = \"control\"\n\n[[channels]]\n  name = \"data-channel\"\n\n  [channels.metadata]\n    type = \"data\"\n\n[[channels]]\n  name = \"export-channel\"\n\n  [channels.metadata]\n    type = \"export\"\n</code></pre> <p><code>[bootstrap.content]</code> will be marshalled and saved into <code>content</code> field in bootstrap configs when request to <code>/mappings</code> is made, <code>content</code> field from bootstrap config is used to create <code>Agent</code> and <code>Export</code> configuration files upon <code>Agent</code> fetching bootstrap configuration.</p>"},{"location":"provision/#authentication","title":"Authentication","text":"<p>In order to create necessary entities provision service needs to authenticate against Mainflux. To provide authentication credentials to the provision service you can pass it in as an environment variable or in a config file as Mainflux user and password or as API token (that can be issued on <code>/users</code> or <code>/keys</code> endpoint of auth.</p> <p>Additionally, users or API token can be passed in Authorization header, this authentication takes precedence over others.</p> <ul> <li><code>username</code>, <code>password</code> - (<code>MF_PROVISION_USER</code>, <code>MF_PROVISION_PASSWORD</code> in .env, <code>mf_user</code>, <code>mf_pass</code> in config.toml</li> <li>API Key - (<code>MF_PROVISION_API_KEY</code> in .env or config.toml</li> <li><code>Authorization: Bearer Token|ApiKey</code> - request authorization header containing either users token or API key. Check auth.</li> </ul>"},{"location":"provision/#running","title":"Running","text":"<p>Provision service can be run as a standalone or in docker composition as addon to the core docker composition.</p> <p>Standalone:</p> <pre><code>MF_PROVISION_BS_SVC_URL=http://localhost:9013/things \\\nMF_PROVISION_THINGS_LOCATION=http://localhost:9000 \\\nMF_PROVISION_USERS_LOCATION=http://localhost:9002 \\\nMF_PROVISION_CONFIG_FILE=docker/addons/provision/configs/config.toml \\\nbuild/mainflux-provision\n</code></pre> <p>Docker composition:</p> <pre><code>docker-compose -f docker/addons/provision/docker-compose.yml up\n</code></pre>"},{"location":"provision/#provision_1","title":"Provision","text":"<p>For the case that credentials or API token is passed in configuration file or environment variables, call to <code>/mapping</code> endpoint doesn't require <code>Authentication</code> header:</p> <pre><code>curl -s -S  -X POST  http://localhost:9016/mapping  -H 'Content-Type: application/json' -d '{\"external_id\": \"33:52:77:99:43\", \"external_key\": \"223334fw2\"}'\n</code></pre> <p>In the case that provision service is not deployed with credentials or API key or you want to use user other than one being set in environment (or config file):</p> <pre><code>curl -s -S  -X POST  http://localhost:9016/mapping -H \"Authorization: Bearer &lt;token|api_key&gt;\" -H 'Content-Type: application/json' -d '{\"external_id\": \"&lt;external_id&gt;\", \"external_key\": \"&lt;external_key&gt;\"}'\n</code></pre> <p>Or if you want to specify a name for thing different than in <code>config.toml</code> you can specify post data as:</p> <pre><code>{\"name\": \"&lt;name&gt;\", \"external_id\": \"&lt;external_id&gt;\", \"external_key\": \"&lt;external_key&gt;\"}\n</code></pre> <p>Response contains created things, channels and certificates if any:</p> <pre><code>{\n  \"things\": [\n    {\n      \"id\": \"c22b0c0f-8c03-40da-a06b-37ed3a72c8d1\",\n      \"name\": \"thing\",\n      \"key\": \"007cce56-e0eb-40d6-b2b9-ed348a97d1eb\",\n      \"metadata\": {\n        \"external_id\": \"33:52:79:C3:43\"\n      }\n    }\n  ],\n  \"channels\": [\n    {\n      \"id\": \"064c680e-181b-4b58-975e-6983313a5170\",\n      \"name\": \"control-channel\",\n      \"metadata\": {\n        \"type\": \"control\"\n      }\n    },\n    {\n      \"id\": \"579da92d-6078-4801-a18a-dd1cfa2aa44f\",\n      \"name\": \"data-channel\",\n      \"metadata\": {\n        \"type\": \"data\"\n      }\n    }\n  ],\n  \"whitelisted\": {\n    \"c22b0c0f-8c03-40da-a06b-37ed3a72c8d1\": true\n  }\n}\n</code></pre>"},{"location":"provision/#example","title":"Example","text":"<p>Deploy Mainflux UI docker composition as it contains all the required services for provisioning to work ( <code>certs</code>, <code>bootstrap</code> and Mainflux core)</p> <pre><code>git clone https://github.com/mainflux/ui\ncd ui\ndocker-compose -f docker/docker-compose.yml up\n</code></pre> <p>Create user and obtain access token</p> <pre><code>mainflux-cli -m https://mainflux.com users create john.doe@email.com 12345678\n\n# Retrieve token\nmainflux-cli -m https://mainflux.com users token john.doe@email.com 12345678\n\ncreated: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTY1ODU3MDUsImlhdCI6MTU5NjU0OTcwNSwiaXNzIjoibWFpbmZsdXguYXV0aG4iLCJzdWIiOiJtaXJrYXNoQGdtYWlsLmNvbSIsInR5cGUiOjB9._vq0zJzFc9tQqc8x74kpn7dXYefUtG9IB0Cb-X2KMK8\n</code></pre> <p>Put a value of token into environment variable</p> <pre><code>TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTY1ODU3MDUsImlhdCI6MTU5NjU0OTcwNSwiaXNzIjoibWFpbmZsdXguYXV0aG4iLCJzdWIiOiJtaXJrYXNoQGdtYWlsLmNvbSIsInR5cGUiOjB9._vq0zJzFc9tQqc8x74kpn7dXYefUtG9IB0Cb-X2KMK8\n</code></pre> <p>Make a call to provision endpoint</p> <pre><code>curl -s -S  -X POST  http://mainflux.com:9016/mapping -H \"Authorization: Bearer $TOKEN\" -H 'Content-Type: application/json'   -d '{\"name\":\"edge-gw\",  \"external_id\" : \"gateway\", \"external_key\":\"external_key\" }'\n</code></pre> <p>To check the results you can make a call to bootstrap endpoint</p> <pre><code>curl -s -S -X GET http://mainflux.com:9013/things/bootstrap/gateway -H \"Authorization: Thing external_key\" -H 'Content-Type: application/json'\n</code></pre> <p>Or you can start <code>Agent</code> with:</p> <pre><code>git clone https://github.com/mainflux/agent\ncd agent\nmake\nMF_AGENT_BOOTSTRAP_ID=gateway MF_AGENT_BOOTSTRAP_KEY=external_key MF_AGENT_BOOTSTRAP_URL=http://mainflux.ccom:9013/things/bootstrap build/mainflux-agent\n</code></pre> <p>Agent will retrieve connections parameters and connect to Mainflux cloud.</p> <p>For more information about the Provision service API, please check out the API documentation.</p>"},{"location":"provision/#certs-service","title":"Certs Service","text":"<p>Issues certificates for things. <code>Certs</code> service can create certificates to be used when <code>Mainflux</code> is deployed to support mTLS. <code>Certs</code> service will create certificate for valid thing ID if valid user token is passed and user is owner of the provided thing ID.</p> <p>Certificate service can create certificates in two modes: 1. Development mode - to be used when no PKI is deployed, this works similar to the make thing_cert 2. PKI mode - certificates issued by PKI, when you deploy <code>Vault</code> as PKI certificate management <code>cert</code> service will proxy requests to <code>Vault</code> previously checking access rights and saving info on successfully created certificate.</p>"},{"location":"provision/#development-mode","title":"Development mode","text":"<p>If <code>MF_CERTS_VAULT_HOST</code> is empty than Development mode is on.</p> <p>To issue a certificate:</p> <pre><code>\nTOKEN=`curl  -s --insecure -S -X POST http://localhost/tokens -H 'Content-Type: application/json' -d '{\"email\":\"edge@email.com\",\"password\":\"12345678\"}' | jq -r '.token'`\n\ncurl -s -S  -X POST  http://localhost:9019/certs -H \"Authorization: Bearer $TOKEN\" -H 'Content-Type: application/json'   -d '{\"thing_id\":&lt;thing_id&gt;, \"rsa_bits\":2048, \"key_type\":\"rsa\"}'\n</code></pre> <pre><code>{\n  \"ThingID\": \"\",\n  \"ClientCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDmTCCAoGgAwIBAgIRANmkAPbTR1UYeYO0Id/4+8gwDQYJKoZIhvcNAQELBQAw\\nVzESMBAGA1UEAwwJbG9jYWxob3N0MREwDwYDVQQKDAhNYWluZmx1eDEMMAoGA1UE\\nCwwDSW9UMSAwHgYJKoZIhvcNAQkBFhFpbmZvQG1haW5mbHV4LmNvbTAeFw0yMDA2\\nMzAxNDIxMDlaFw0yMDA5MjMyMjIxMDlaMFUxETAPBgNVBAoTCE1haW5mbHV4MREw\\nDwYDVQQLEwhtYWluZmx1eDEtMCsGA1UEAxMkYjAwZDBhNzktYjQ2YS00NTk3LTli\\nNGYtMjhkZGJhNTBjYTYyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\\ntgS2fLUWG3CCQz/l6VRQRJfRvWmdxK0mW6zIXGeeOILYZeaLiuiUnohwMJ4RiMqT\\nuJbInAIuO/Tt5osfrCFFzPEOLYJ5nZBBaJfTIAxqf84Ou1oeMRll4wpzgeKx0rJO\\nXMAARwn1bT9n3uky5QQGSLy4PyyILzSXH/1yCQQctdQB/Ar/UI1TaYoYlGzh7dHT\\nWpcxq1HYgCyAtcrQrGD0rEwUn82UBCrnya+bygNqu0oDzIFQwa1G8jxSgXk0mFS1\\nWrk7rBipsvp8HQhdnvbEVz4k4AAKcQxesH4DkRx/EXmU2UvN3XysvcJ2bL+UzMNI\\njNhAe0pgPbB82F6zkYZ/XQIDAQABo2IwYDAOBgNVHQ8BAf8EBAMCB4AwHQYDVR0l\\nBBYwFAYIKwYBBQUHAwIGCCsGAQUFBwMBMA4GA1UdDgQHBAUBAgMEBjAfBgNVHSME\\nGDAWgBRs4xR91qEjNRGmw391xS7x6Tc+8jANBgkqhkiG9w0BAQsFAAOCAQEAW/dS\\nV4vNLTZwBnPVHUX35pRFxPKvscY+vnnpgyDtITgZHYe0KL+Bs3IHuywtqaezU5x1\\nkZo+frE1OcpRvp7HJtDiT06yz+18qOYZMappCWCeAFWtZkMhlvnm3TqTkgui6Xgl\\nGj5xnPb15AOlsDE2dkv5S6kEwJGHdVX6AOWfB4ubUq5S9e4ABYzXGUty6Hw/ZUmJ\\nhCTRVJ7cQJVTJsl1o7CYT8JBvUUG75LirtoFE4M4JwsfsKZXzrQffTf1ynqI3dN/\\nHWySEbvTSWcRcA3MSmOTxGt5/zwCglHDlWPKMrXtjTW7NPuGL5/P9HSB9HGVVeET\\nDUMdvYwgj0cUCEu3LA==\\n-----END CERTIFICATE-----\\n\",\n  \"IssuingCA\": \"\",\n  \"CAChain\": null,\n  \"ClientKey\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEowIBAAKCAQEAtgS2fLUWG3CCQz/l6VRQRJfRvWmdxK0mW6zIXGeeOILYZeaL\\niuiUnohwMJ4RiMqTuJbInAIuO/Tt5osfrCFFzPEOLYJ5nZBBaJfTIAxqf84Ou1oe\\nMRll4wpzgeKx0rJOXMAARwn1bT9n3uky5QQGSLy4PyyILzSXH/1yCQQctdQB/Ar/\\nUI1TaYoYlGzh7dHTWpcxq1HYgCyAtcrQrGD0rEwUn82UBCrnya+bygNqu0oDzIFQ\\nwa1G8jxSgXk0mFS1Wrk7rBipsvp8HQhdnvbEVz4k4AAKcQxesH4DkRx/EXmU2UvN\\n3XysvcJ2bL+UzMNIjNhAe0pgPbB82F6zkYZ/XQIDAQABAoIBAALoal3tqq+/iWU3\\npR2oKiweXMxw3oNg3McEKKNJSH7QoFJob3xFoPIzbc9pBxCvY9LEHepYIpL0o8RW\\nHqhqU6olg7t4ZSb+Qf1Ax6+wYxctnJCjrO3N4RHSfevqSjr6fEQBEUARSal4JNmr\\n0hNUkCEjWrIvrPFMHsn1C5hXR3okJQpGsad4oCGZDp2eZ/NDyvmLBLci9/5CJdRv\\n6roOF5ShWweKcz1+pfy666Q8RiUI7H1zXjPaL4yqkv8eg/WPOO0dYF2Ri2Grk9OY\\n1qTM0W1vi9zfncinZ0DpgtwMTFQezGwhUyJHSYHmjVBA4AaYIyOQAI/2dl5fXM+O\\n9JfXpOUCgYEA10xAtMc/8KOLbHCprpc4pbtOqfchq/M04qPKxQNAjqvLodrWZZgF\\nexa+B3eWWn5MxmQMx18AjBCPwbNDK8Rkd9VqzdWempaSblgZ7y1a0rRNTXzN5DFP\\noiuRQV4wszCuj5XSdPn+lxApaI/4+TQ0oweIZCpGW39XKePPoB5WZiMCgYEA2G3W\\niJncRpmxWwrRPi1W26E9tWOT5s9wYgXWMc+PAVUd/qdDRuMBHpu861Qoghp/MJog\\nBYqt2rQqU0OxvIXlXPrXPHXrCLOFwybRCBVREZrg4BZNnjyDTLOu9C+0M3J9ImCh\\n3vniYqb7S0gRmoDM0R3Zu4+ajfP2QOGLXw1qHH8CgYEAl0EQ7HBW8V5UYzi7XNcM\\nixKOb0YZt83DR74+hC6GujTjeLBfkzw8DX+qvWA8lxLIKVC80YxivAQemryv4h21\\nX6Llx/nd1UkXUsI+ZhP9DK5y6I9XroseIRZuk/fyStFWsbVWB6xiOgq2rKkJBzqw\\nCCEQpx40E6/gsqNDiIAHvvUCgYBkkjXc6FJ55DWMLuyozfzMtpKsVYeG++InSrsM\\nDn1PizQS/7q9mAMPLCOP312rh5CPDy/OI3FCbfI1GwHerwG0QUP/bnQ3aOTBmKoN\\n7YnsemIA/5w16bzBycWE5x3/wjXv4aOWr9vJJ/siMm0rtKp4ijyBcevKBxHpeGWB\\nWAR1FQKBgGIqAxGnBpip9E24gH894BaGHHMpQCwAxARev6sHKUy27eFUd6ipoTva\\n4Wv36iz3gxU4R5B0gyfnxBNiUab/z90cb5+6+FYO13kqjxRRZWffohk5nHlmFN9K\\nea7KQHTfTdRhOLUzW2yVqLi9pzfTfA6Yqf3U1YD3bgnWrp1VQnjo\\n-----END RSA PRIVATE KEY-----\\n\",\n  \"PrivateKeyType\": \"\",\n  \"Serial\": \"\",\n  \"Expire\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre>"},{"location":"provision/#pki-mode","title":"PKI mode","text":"<p>When <code>MF_CERTS_VAULT_HOST</code> is set it is presumed that <code>Vault</code> is installed and <code>certs</code> service will issue certificates using <code>Vault</code> API. First you'll need to set up <code>Vault</code>. To setup <code>Vault</code> follow steps in Build Your Own Certificate Authority (CA).</p> <p>To setup certs service with <code>Vault</code> following environment variables must be set:</p> <pre><code>MF_CERTS_VAULT_HOST=vault-domain.com\nMF_CERTS_VAULT_PKI_PATH=&lt;vault_pki_path&gt;\nMF_CERTS_VAULT_ROLE=&lt;vault_role&gt;\nMF_CERTS_VAULT_TOKEN=&lt;vault_acces_token&gt;\n</code></pre> <p>For lab purposes you can use docker-compose and script for setting up PKI in https://github.com/mteodor/vault</p> <p>Issuing certificate is same as in Development mode. In this mode certificates can also be revoked:</p> <pre><code>curl -s -S -X DELETE http://localhost:9019/certs/revoke -H \"Authorization: Bearer $TOKEN\" -H 'Content-Type: application/json'   -d '{\"thing_id\":\"c30b8842-507c-4bcd-973c-74008cef3be5\"}'\n</code></pre> <p>For more information about the Certification service API, please check out the API documentation.</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#server-configuration","title":"Server Configuration","text":""},{"location":"security/#users","title":"Users","text":"<p>If either the cert or key is not set, the server will use insecure transport.</p> <p><code>MF_USERS_SERVER_CERT</code> the path to server certificate in pem format.</p> <p><code>MF_USERS_SERVER_KEY</code> the path to the server key in pem format.</p>"},{"location":"security/#things","title":"Things","text":"<p>If either the cert or key is not set, the server will use insecure transport.</p> <p><code>MF_THINGS_SERVER_CERT</code> the path to server certificate in pem format.</p> <p><code>MF_THINGS_SERVER_KEY</code> the path to the server key in pem format.</p>"},{"location":"security/#standalone-mode","title":"Standalone mode","text":"<p>Sometimes it makes sense to run Things as a standalone service to reduce network traffic or simplify deployment. This means that Things service operates only using a single user and is able to authorize it without gRPC communication with Auth service. When running Things in the standalone mode, <code>Auth</code> and <code>Users</code> services can be omitted from the deployment. To run service in a standalone mode, set <code>MF_THINGS_STANDALONE_EMAIL</code> and <code>MF_THINGS_STANDALONE_TOKEN</code>.</p>"},{"location":"security/#client-configuration","title":"Client Configuration","text":"<p>If you wish to secure the gRPC connection to <code>Things</code> and <code>Users</code> services you must define the CAs that you trust.  This does not support mutual certificate authentication.</p>"},{"location":"security/#adapter-configuration","title":"Adapter Configuration","text":"<p><code>MF_HTTP_ADAPTER_CA_CERTS</code>, <code>MF_MQTT_ADAPTER_CA_CERTS</code>, <code>MF_WS_ADAPTER_CA_CERTS</code>, <code>MF_COAP_ADAPTER_CA_CERTS</code> - the path to a file that contains the CAs in PEM format. If not set, the default connection will be insecure. If it fails to read the file, the adapter will fail to start up.</p>"},{"location":"security/#things_1","title":"Things","text":"<p><code>MF_THINGS_CA_CERTS</code> - the path to a file that contains the CAs in PEM format. If not set, the default connection will be insecure. If it fails to read the file, the service will fail to start up.</p>"},{"location":"security/#securing-postgresql-connections","title":"Securing PostgreSQL Connections","text":"<p>By default, Mainflux will connect to Postgres using insecure transport. If a secured connection is required, you can select the SSL mode and set paths to any extra certificates and keys needed.</p> <p><code>MF_USERS_DB_SSL_MODE</code> the SSL connection mode for Users. <code>MF_USERS_DB_SSL_CERT</code> the path to the certificate file for Users. <code>MF_USERS_DB_SSL_KEY</code> the path to the key file for Users. <code>MF_USERS_DB_SSL_ROOT_CERT</code> the path to the root certificate file for Users.</p> <p><code>MF_THINGS_DB_SSL_MODE</code> the SSL connection mode for Things. <code>MF_THINGS_DB_SSL_CERT</code> the path to the certificate file for Things. <code>MF_THINGS_DB_SSL_KEY</code> the path to the key file for Things. <code>MF_THINGS_DB_SSL_ROOT_CERT</code> the path to the root certificate file for Things.</p> <p>Supported database connection modes are: <code>disabled</code> (default), <code>required</code>, <code>verify-ca</code> and <code>verify-full</code>.</p>"},{"location":"security/#securing-grpc","title":"Securing gRPC","text":"<p>By default gRPC communication is not secure as Mainflux system is most often run in a private network behind the reverse proxy.</p> <p>However, TLS can be activated and configured.</p>"},{"location":"storage/","title":"Storage","text":"<p>Mainflux supports various storage databases in which messages are stored:</p> <ul> <li>CassandraDB</li> <li>MongoDB</li> <li>InfluxDB</li> <li>PostgreSQL</li> </ul> <p>These storages are activated via docker-compose add-ons.</p> <p>The <code>&lt;project_root&gt;/docker</code> folder contains an <code>addons</code> directory. This directory is used for various services that are not core to the Mainflux platform but could be used for providing additional features.</p> <p>In order to run these services, core services, as well as the network from the core composition, should be already running.</p>"},{"location":"storage/#writers","title":"Writers","text":"<p>Writers provide an implementation of various <code>message writers</code>. Message writers are services that consume Mainflux messages, transform them to desired format and store them in specific data store. The path of the configuration file can be set using the following environment variables: <code>MF_CASSANDRA_WRITER_CONFIG_PATH</code>, <code>MF_POSTGRES_WRITER_CONFIG_PATH</code>, <code>MF_INFLUX_WRITER_CONFIG_PATH</code> and <code>MF_MONGO_WRITER_CONFIG_PATH</code>.</p>"},{"location":"storage/#subscriber-config","title":"Subscriber config","text":"<p>Each writer can filter messages based on subjects list that is set in <code>config.toml</code> configuration file. If you want to listen on all subjects, just set the field <code>subjects</code> in the <code>[subscriber]</code> section as <code>[\"channels.&gt;\"]</code>, otherwise pass the list of subjects. Here is an example:</p> <pre><code>[subscriber]\nsubjects = [\"channels.*.messages.bedroom.temperature\",\"channels.*.messages.bedroom.humidity\"]\n</code></pre> <p>Regarding the Subtopics Section in the messaging page, the example <code>channels/&lt;channel_id&gt;/messages/bedroom/temperature</code> can be filtered as <code>\"channels.*.bedroom.temperature\"</code>. The formatting of this filtering list is determined by the default message broker, NATS, format (Subject-Based Messaging &amp; Wildcards).</p>"},{"location":"storage/#transformer-config","title":"Transformer config","text":"<p>There are two types of transformers: SenML and JSON. The transformer type is set in configuration file.</p> <p>For SenML transformer, supported message payload formats are SenML+CBOR and SenML+JSON. They are configurable over <code>content_type</code> field in the <code>[transformer]</code> section and expect <code>application/senml+json</code> or <code>application/senml+cbor</code> formats. Here is an example:</p> <pre><code>[transformer]\nformat = \"senml\"\ncontent_type = \"application/senml+json\"\n</code></pre> <p>Usually, the payload of the IoT message contains message time. It can be in different formats (like base time and record time in the case of SenML) and the message field can be under the arbitrary key. Usually, we would want to map that time to the Mainflux Message field Created and for that reason, we need to configure the Transformer to be able to read the field, parse it using proper format and location (if devices time is different than the service time), and map it to Mainflux Message.</p> <p>For JSON transformer you can configure <code>time_fields</code> in the <code>[transformer]</code> section to use arbitrary fields from the JSON message payload as timestamp. <code>time_fields</code> is represented by an array of objects with fields <code>field_name</code>, <code>field_format</code> and <code>location</code> that represent respectively the name of the JSON key to use as timestamp, the time format to use for the field value and the time location. Here is an example:</p> <pre><code>[transformer]\nformat = \"json\"\ntime_fields = [{ field_name = \"seconds_key\", field_format = \"unix\",    location = \"UTC\"},\n               { field_name = \"millis_key\",  field_format = \"unix_ms\", location = \"UTC\"},\n               { field_name = \"micros_key\",  field_format = \"unix_us\", location = \"UTC\"},\n               { field_name = \"nanos_key\",   field_format = \"unix_ns\", location = \"UTC\"}]\n\n\nJSON transformer can be used for any JSON payload. For the messages that contain _JSON array as the root element_, JSON Transformer does normalization of the data: it creates a separate JSON message for each JSON object in the root. In order to be processed and stored properly, JSON messages need to contain message format information. For the sake of simplicity, nested JSON objects are flatten to a single JSON object in InfluxDB, using composite keys separated by the `/` separator. This implies that the separator character (`/`) _is not allowed in the JSON object key_ while using InfluxDB. Apart from InfluxDB, separator character (`/`) usage in the JSON object key is permitted, since other [Writer](storage.md#writers) types do not flat the nested JSON objects. For example, the following JSON object:\n```json\n{\n    \"name\": \"name\",\n    \"id\":8659456789564231564,\n    \"in\": 3.145,\n    \"alarm\": true,\n    \"ts\": 1571259850000,\n    \"d\": {\n        \"tmp\": 2.564,\n        \"hmd\": 87,\n        \"loc\": {\n            \"x\": 1,\n            \"y\": 2\n        }\n    }\n}\n</code></pre> <p>for InfluxDB will be transformed to:</p> <pre><code>{\n    \"name\": \"name\",\n    \"id\":8659456789564231564,\n    \"in\": 3.145,\n    \"alarm\": true,\n    \"ts\": 1571259850000,\n    \"d/tmp\": 2.564,\n    \"d/hmd\": 87,\n    \"d/loc/x\": 1,\n    \"d/loc/y\": 2\n}\n</code></pre> <p>while for other Writers it will preserve its original format.</p> <p>The message format is stored in the subtopic. It's the last part of the subtopic. In the example:</p> <pre><code>http://localhost:8008/channels/&lt;channelID&gt;/messages/home/temperature/myFormat\n</code></pre> <p>the message format is <code>myFormat</code>. It can be any valid subtopic name, JSON transformer is format-agnostic. The format is used by the JSON message consumers so that they can process the message properly. If the format is not present (i.e. message subtopic is empty), JSON Transformer will report an error.  Message writers will store the message(s) in the table/collection/measurement (depending on the underlying database) with the name of the format (which in the example is <code>myFormat</code>). Mainflux writers will try to save any format received (whether it will be successful depends on the writer implementation and the underlying database), but it's recommended that publishers don't send different formats to the same subtopic.</p>"},{"location":"storage/#influxdb-influxdb-writer","title":"InfluxDB, InfluxDB Writer","text":"<p>From the project root execute the following command:</p> <pre><code>docker-compose -f docker/addons/influxdb-writer/docker-compose.yml up -d\n</code></pre> <p>This will install and start:</p> <ul> <li>InfluxDB - time series database</li> <li>InfluxDB writer - message repository implementation for InfluxDB</li> </ul> <p>Those new services will take some additional ports:</p> <ul> <li>8086 by InfluxDB</li> <li>9006 by InfluxDB writer service</li> </ul> <p>To access Influx-UI, navigate to <code>http://localhost:8086</code> and login with: <code>mainflux</code>, password: <code>mainflux</code></p>"},{"location":"storage/#cassandra-and-cassandra-writer","title":"Cassandra and Cassandra Writer","text":"<pre><code>./docker/addons/cassandra-writer/init.sh\n</code></pre> <p>Please note that Cassandra may not be suitable for your testing environment because of its high system requirements.</p>"},{"location":"storage/#mongodb-and-mongodb-writer","title":"MongoDB and MongoDB Writer","text":"<pre><code>docker-compose -f docker/addons/mongodb-writer/docker-compose.yml up -d\n</code></pre> <p>MongoDB default port (27017) is exposed, so you can use various tools for database inspection and data visualization.</p>"},{"location":"storage/#postgresql-and-postgresql-writer","title":"PostgreSQL and PostgreSQL Writer","text":"<pre><code>docker-compose -f docker/addons/postgres-writer/docker-compose.yml up -d\n</code></pre> <p>Postgres default port (5432) is exposed, so you can use various tools for database inspection and data visualization.</p>"},{"location":"storage/#readers","title":"Readers","text":"<p>Readers provide an implementation of various <code>message readers</code>. Message readers are services that consume normalized (in <code>SenML</code> format) Mainflux messages from data storage and opens HTTP API for message consumption. Installing corresponding writer before reader is implied.</p> <p>Each of the Reader services exposes the same HTTP API for fetching messages on its default port.</p> <p>To read sent messages on channel with id <code>channel_id</code> you should send <code>GET</code> request to <code>/channels/&lt;channel_id&gt;/messages</code> with thing access token in <code>Authorization</code> header. That thing must be connected to  channel with <code>channel_id</code></p> <p>Response should look like this:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nDate: Tue, 18 Sep 2018 18:56:19 GMT\nContent-Length: 228\n\n{\n    \"messages\": [\n        {\n            \"Channel\": 1,\n            \"Publisher\": 2,\n            \"Protocol\": \"mqtt\",\n            \"Name\": \"name:voltage\",\n            \"Unit\": \"V\",\n            \"Value\": 5.6,\n            \"Time\": 48.56\n        },\n        {\n            \"Channel\": 1,\n            \"Publisher\": 2,\n            \"Protocol\": \"mqtt\",\n            \"Name\": \"name:temperature\",\n            \"Unit\": \"C\",\n            \"Value\": 24.3,\n            \"Time\": 48.56\n        }\n    ]\n}\n</code></pre> <p>Note that you will receive only those messages that were sent by authorization token's owner. You can specify <code>offset</code> and <code>limit</code> parameters in order to fetch specific group of messages. An example of HTTP request looks like:</p> <pre><code>curl -s -S -i  -H \"Authorization: Thing &lt;thing_key&gt;\" http://localhost:&lt;service_port&gt;/channels/&lt;channel_id&gt;/messages?offset=0&amp;limit=5&amp;format=&lt;subtopic&gt;\n</code></pre> <p>If you don't provide <code>offset</code> and <code>limit</code> parameters, default values will be used instead: 0 for <code>offset</code> and 10 for <code>limit</code>. The <code>format</code> parameter indicates the last subtopic of the message. As indicated under the <code>Writers</code> section, the message format is stored in the subtopic as the last part of the subtopic. In the example:</p> <pre><code>http://localhost:&lt;service_port&gt;/channels/&lt;channelID&gt;/messages/home/temperature/myFormat\n</code></pre> <p>the message format is <code>myFormat</code> and the value for <code>format=&lt;subtopic&gt;</code> is <code>format=myFormat</code>.</p>"},{"location":"storage/#influxdb-reader","title":"InfluxDB Reader","text":"<p>To start InfluxDB reader, execute the following command:</p> <pre><code>docker-compose -f docker/addons/influxdb-reader/docker-compose.yml up -d\n</code></pre>"},{"location":"storage/#cassandra-reader","title":"Cassandra Reader","text":"<p>To start Cassandra reader, execute the following command:</p> <pre><code>docker-compose -f docker/addons/cassandra-reader/docker-compose.yml up -d\n</code></pre>"},{"location":"storage/#mongodb-reader","title":"MongoDB Reader","text":"<p>To start MongoDB reader, execute the following command:</p> <pre><code>docker-compose -f docker/addons/mongodb-reader/docker-compose.yml up -d\n</code></pre>"},{"location":"storage/#postgresql-reader","title":"PostgreSQL Reader","text":"<p>To start PostgreSQL reader, execute the following command:</p> <pre><code>docker-compose -f docker/addons/postgres-reader/docker-compose.yml up -d\n</code></pre>"},{"location":"tracing/","title":"Tracing","text":"<p>Distributed tracing is a method of profiling and monitoring applications.  It can provide valuable insight when optimizing and debugging an application.  Mainflux includes the Jaeger open tracing framework as a service with its stack by default.</p>"},{"location":"tracing/#launch","title":"Launch","text":"<p>The Jaeger service will launch with the rest of the Mainflux services.  All services can be launched using:</p> <pre><code>make run\n</code></pre> <p>The Jaeger UI can then be accessed at <code>http://localhost:16686</code> from a browser.  Details about the UI can be found in Jaeger's official documentation.</p>"},{"location":"tracing/#configure","title":"Configure","text":"<p>The Jaeger service can be disabled by using the <code>scale</code> flag with <code>docker-compose up</code> and setting the jaeger container to 0.</p> <pre><code>--scale jaeger=0\n</code></pre> <p><code>make rungw</code> will run all of the Mainflux services except for the Jaeger service.  This is currently the only difference from <code>make run</code>.  </p> <p>The <code>make rungw</code> command runs Mainflux for gateway devices.  There could potentially be more differences running with this command in the future.</p> <p>Jaeger uses 5 ports within the Mainflux framework.  These ports can be edited in the <code>.env</code> file.</p> Variable Description Default MF_JAEGER_PORT Agent port for compact jaeger.thrift protocol 6831 MF_JAEGER_FRONTEND UI port 16686 MF_JAEGER_COLLECTOR Collector for jaeger.thrift directly from clients 14268 MF_JAEGER_CONFIGS Configuration server 5778 MF_JAEGER_URL Jaeger access from within Mainflux jaeger:6831"},{"location":"tracing/#example","title":"Example","text":"<p>As an example for using Jaeger, we can look at the traces generated after provisioning the system.  Make sure to have ran the provisioning script that is part of the Getting Started step.</p> <p>Before getting started with Jaeger, there are a few terms that are important to define.  A <code>trace</code> can be thought of as one transaction within the system.  A trace is made up of one or more <code>spans</code>.  These are the individual steps that must be taken for a trace to perform its action.  A span has <code>tags</code> and <code>logs</code> associated with it.  Tags are key-value pairs that provide information such as a database type or http method. Tags are useful when filtering traces in the Jaeger UI.  Logs are structured messages used at specific points in the trace's transaction.  These are typically used to indicate an error.</p> <p>When first navigating to the Jaeger UI, it will present a search page with an empty results section.  There are multiple fields to search from including service, operation, tags and time frames.  Clicking <code>Find Traces</code> will fill the results section with traces containing the selected fields.</p> <p></p> <p>The top of the results page includes a scatter plot of the traces and their durations.  This can be very useful for finding a trace with a prolonged runtime.  Clicking on one of the points will open the trace page of that trace.</p> <p>Below the graph is a list of all the traces with a summary of its information. Each trace shows a unique identifier, the overall runtime, the spans it is composed of and when it was ran.  Clicking on one of the traces will open the trace page of that trace.</p> <p></p> <p>The trace page provides a more detailed breakdown of the individual span calls.  The top of the page shows a chart breaking down what spans the trace is spending its time in.  Below the chart are the individual spans and their details.  Expanding the spans shows any tags associated with that span and process information.  This is also where any errors or logs seen while running the span will be reported.</p> <p>This is just a brief overview of the possibilities of Jaeger and its UI.  For more information, check out Jaeger's official documentation.</p>"},{"location":"twins/","title":"Twins","text":""},{"location":"twins/#twins-service","title":"Twins Service","text":"<p>Mainflux twins service is built on top of the Mainflux platform. In order to fully understand what follows, be sure to get acquainted with overall Mainflux architecture.</p>"},{"location":"twins/#what-is-digital-twin","title":"What is Digital Twin","text":"<p>Twin refers to a digital representation of a real world data system consisting of possibly multiple data sources/producers and/or destinations/consumers (data agents).</p> <p>For example, an industrial machine can use multiple protocols such as MQTT, OPC-UA, a regularly updated machine hosted CSV file etc. to send measurement data - such as flowrate, material temperature, etc. - and state metadata - such as engine and chassis temperature, engine rotations per seconds, identity of the current human operator, etc. - as well as to receive control, i.e. actuation messages - such as, turn on/off light, increment/decrement borer speed, change blades, etc.</p> <p>Digital twin is an abstract - and usually less detailed - digital replica of a real world system such as the industrial machine we have just described. It is used to create and store information about system's state at any given moment, to compare system state over a given period of time - so-called diffs or deltas - as well as to control agents composing the system.</p>"},{"location":"twins/#mainflux-digital-twin","title":"Mainflux Digital Twin","text":"<p>Any data producer or data consumer - which we refer to here collectively as data agent - or an interrelated system of data agents, can be represented by means of possibly multiple Mainflux things, channels and subtopics. For example, an OPC-UA server can be represented as a Mainflux thing and its nodes can be represented as multiple Mainflux channels or multiple subtopics of a single Mainflux channel. What is more, you can invert the representation: you can represent server as a channel and node as things. Mainflux platform is meant to empower you with the freedom of expression so you can make a digital representation of any data agent according to your needs.</p> <p>Although this works well, satisfies the requirements of a wide variety of use cases and corresponds to the intended use of Mainlfux IoT platform, this setup can be insufficient in two important ways. Firstly, different things, channels, and their connections - i.e. Mainflux representations of different data agent structures - are unrelated to each other, i.e. they do not form a meaningful whole and, as a consequence, they do not represent a single unified system. Secondly, the semantic aspect, i.e. the meaning of different things and channels is not transparent and defined by the sole use of Mainflux platform entities (channels and things).</p> <p>Certainly, we can try to describe things and channels connections and relations as well as their meaning - i.e. their role, position, function in the overall system - by means of their metadata. Although this might work well - with a proviso of a lot of additional effort of writing the relatively complex code to create and parse metadata - it is not a practical approach and we still don't get - at least not out of the box - a readable and useful overview of the system as a whole. Also, this approach does not enable us to answer a simple but very important question, i.e. what was the detailed state of a complete system at a certain moment in time.</p> <p>To overcome these problems, Mainflux comes with a digital twin service. The twins service is built on top of the Mainflux platform and relies on its architecture and entities, more precisely, on Mainflux users, things and channels. The primary task of the twin service is to handle Mainflux digital twins. Mainflux digital twin consists of three parts:</p> <ul> <li>General data about twin itself, i.e. twin's metadata,</li> <li>History of twin's definitions, including current definition,</li> <li>History of twin's states, including current state.</li> </ul>"},{"location":"twins/#mainflux-platform-and-mainflux-twins-service","title":"Mainflux Platform and Mainflux Twins Service","text":"<p>Mainflux Twins service depends on the Mainflux IoT platform. The following diagram shows the place of the twins service in the overall Mainflux architecture:</p> <p></p> <p>You use an HTTP client to communicate with the twins service. Every request sent to the twins service is authenticated by users service. Twins service handles CRUD requests and creates, retrieves, updates and deletes twins. The CRUD operations depend on the database to persist and fetch already saved twins.</p> <p>Twins service listens to the message broker server and intercepts messages passing via the message broker. Every Mainflux message contains information about subchannel and topic used to send a message. Twins service compares this info with attribute definitions of twins persisted in the database, fetches the corresponding twins and updates their respective states.</p> <p>Before we dwell into twin's anatomy, it is important to realize that in order to use Mainflux twin service, you have to provision Mainflux things and channels and you have to connect things and channels beforehand. As you go, you can modify your things, channels and connections and you can modify your digital twin to reflect these modifications, but you have to have at least a minimal setup in order to use the twin service.</p>"},{"location":"twins/#twins-anatomy","title":"Twin's Anatomy","text":"<p>Twin's general information stores twin's owner email - owner is represented by Mainflux user -, twin's ID (unique) and name (not necessarily unique), twin's creation and update dates as well as twin's revision number. The latter refers to the sequential number of twin's definition.</p> <p>The twin's definition is meant to be a semantic representation of system's data sources and consumers (data agents). Each data data agent is represented by means of attribute. Attribute consists of data agent's name, Mainflux channel and subtopic over which it communicates. Nota bene: each attribute is uniquely defined by the combination of channel and subtopic and we cannot have two or more attributes with the same channel and subtopic in the same definition.</p> <p>Attributes have a state persistence flag that determines whether the messages communicated by its corresponding channel and subtopic trigger the creation of a new twin state. Twin states are persisted in the separate collection of the same database. Currently, twins service uses the MongoDB. InfluxDB support for twins and states persistence is on the roadmap.</p> <p>When we define our digital twin, its JSON representation might look like this:</p> <pre><code>{\n    \"owner\": \"john.doe@email.net\",\n    \"id\": \"a838e608-1c1b-4fea-9c34-def877473a89\",\n    \"name\": \"grinding machine 2\",\n    \"revision\": 2,\n    \"created\": \"2020-05-05T08:41:39.142Z\",\n    \"updated\": \"2020-05-05T08:49:12.638Z\",\n    \"definitions\": [\n        {\n            \"id\": 0,\n            \"created\": \"2020-05-05T08:41:39.142Z\",\n            \"attributes\": [],\n            \"delta\": 1000000\n        },\n        {\n            \"id\": 1,\n            \"created\": \"2020-05-05T08:46:23.207Z\",\n            \"attributes\": [\n                {\n                    \"name\": \"engine temperature\",\n                    \"channel\": \"7ef6c61c-f514-402f-af4b-2401b588bfec\",\n                    \"subtopic\": \"engine\",\n                    \"persist_state\": true\n                },\n                {\n                    \"name\": \"chassis temperature\",\n                    \"channel\": \"7ef6c61c-f514-402f-af4b-2401b588bfec\",\n                    \"subtopic\": \"chassis\",\n                    \"persist_state\": true\n                },\n                {\n                    \"name\": \"rotations per sec\",\n                    \"channel\": \"a254032a-8bb6-4973-a2a1-dbf80f181a86\",\n                    \"subtopic\": \"\",\n                    \"persist_state\": false\n                }\n            ],\n            \"delta\": 1000000\n        },\n        {\n            \"id\": 2,\n            \"created\": \"2020-05-05T08:49:12.638Z\",\n            \"attributes\": [\n                {\n                    \"name\": \"engine temperature\",\n                    \"channel\": \"7ef6c61c-f514-402f-af4b-2401b588bfec\",\n                    \"subtopic\": \"engine\",\n                    \"persist_state\": true\n                },\n                {\n                    \"name\": \"chassis temperature\",\n                    \"channel\": \"7ef6c61c-f514-402f-af4b-2401b588bfec\",\n                    \"subtopic\": \"chassis\",\n                    \"persist_state\": true\n                },\n                {\n                    \"name\": \"rotations per sec\",\n                    \"channel\": \"a254032a-8bb6-4973-a2a1-dbf80f181a86\",\n                    \"subtopic\": \"\",\n                    \"persist_state\": false\n                },\n                {\n                    \"name\": \"precision\",\n                    \"channel\": \"aed0fbca-0d1d-4b07-834c-c62f31526569\",\n                    \"subtopic\": \"\",\n                    \"persist_state\": true\n                }\n            ],\n            \"delta\": 1000000\n        }\n    ]\n}\n</code></pre> <p>In the case of the upper twin, we begin with an empty definition, the one with the <code>id</code> 0 - we could have provided the definition immediately - and over the course of time, we add two more definitions, so the total number of revisions is 2 (revision index is zero-based). We decide not to persist the number of rotation per second in our digital twin state. We define it, though, because the definition and its attributes are used not only to define states of a complex data agent system, but also to define the semantic structure of the system. <code>delta</code> is the number of nanoseconds used to determine whether the received attribute value should trigger the generation of the new state or the same state should be updated. The reason for this is to enable state sampling over the regular intervals of time. Discarded values are written to the database of choice by Mainflux writers, so you can always retrieve intermediate values if need be.</p> <p>states are created according to the twin's current definition. A state stores twin's ID - every state belongs to a single twin -, its own ID, twin's definition number, creation date and the actual payload. Payload is a set of key-value pairs where a key corresponds to the attribute name and a value is the actual value of the attribute. All SenML value types are supported.</p> <p>A JSON representation of a partial list of states might look like this:</p> <pre><code>{\n    \"total\": 28,\n    \"offset\": 10,\n    \"limit\": 5,\n    \"states\": [\n        {\n            \"twin_id\": \"a838e608-1c1b-4fea-9c34-def877473a89\",\n            \"id\": 11,\n            \"definition\": 1,\n            \"created\": \"2020-05-05T08:49:06.167Z\",\n            \"payload\": {\n                \"chassis temperature\": 0.3394171011161684,\n                \"engine temperature\": 0.3814079472715233\n            }\n        },\n        {\n            \"twin_id\": \"a838e608-1c1b-4fea-9c34-def877473a89\",\n            \"id\": 12,\n            \"definition\": 1,\n            \"created\": \"2020-05-05T08:49:12.168Z\",\n            \"payload\": {\n                \"chassis temperature\": 1.8116442194724147,\n                \"engine temperature\": 0.3814079472715233\n            }\n        },\n        {\n            \"twin_id\": \"a838e608-1c1b-4fea-9c34-def877473a89\",\n            \"id\": 13,\n            \"definition\": 2,\n            \"created\": \"2020-05-05T08:49:18.174Z\",\n            \"payload\": {\n                \"chassis temperature\": 1.8116442194724147,\n                \"engine temperature\": 3.2410616702795814\n            }\n        },\n        {\n            \"twin_id\": \"a838e608-1c1b-4fea-9c34-def877473a89\",\n            \"id\": 14,\n            \"definition\": 2,\n            \"created\": \"2020-05-05T08:49:19.145Z\",\n            \"payload\": {\n                \"chassis temperature\": 3.2410616702795814,\n                \"engine temperature\": 3.2410616702795814,\n                \"precision\": 8.922156489392854\n            }\n        },\n        {\n            \"twin_id\": \"a838e608-1c1b-4fea-9c34-def877473a89\",\n            \"id\": 15,\n            \"definition\": 2,\n            \"created\": \"2020-05-05T08:49:24.178Z\",\n            \"payload\": {\n                \"chassis temperature\": 0.8694383878692546,\n                \"engine temperature\": 3.2410616702795814,\n                \"precision\": 8.922156489392854\n            }\n        }\n    ]\n}\n</code></pre> <p>As you can see, the first two states correspond to the definition 1 and have only two attributes in the payload. The rest of the states is based on the definition 2, where we persist three attributes and, as a consequence, its payload consists of three entries.</p>"},{"location":"twins/#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>Twin belongs to a Mainflux user, tenant representing a physical person or an organization. User owns Mainflux things and channels as well as twins. Mainflux user provides authorization and authentication mechanisms to twins service. For more details, please see Authentication with Mainflux keys. In practical terms, we need to create a Mainflux user in order to create a digital twin. Every twin belongs to exactly one user. One user can have unlimited number of digital twins.</p>"},{"location":"twins/#twin-operations","title":"Twin Operations","text":"<p>For more information about the Twins service HTTP API please refer to the twins service OpenAPI file.</p>"},{"location":"twins/#create-and-update","title":"Create and Update","text":"<p>Create and update requests use JSON body to initialize and modify, respectively, twin. You can omit every piece of data - every key-value pair - from the JSON. However, you must send at least an empty JSON body.</p> <pre><code>{\n  \"name\": \"twin_name\",\n  \"definition\": {\n    \"attributes\": [\n      {\n        \"name\": \"temperature\",\n        \"channel\": \"3b57b952-318e-47b5-b0d7-a14f61ecd03b\",\n        \"subtopic\": \"temperature\",\n        \"persist_state\": true\n      },\n      {\n        \"name\": \"humidity\",\n        \"channel\": \"3b57b952-318e-47b5-b0d7-a14f61ecd03b\",\n        \"subtopic\": \"humidity\",\n        \"persist_state\": false\n      },\n      {\n        \"name\": \"pressure\",\n        \"channel\": \"7ef6c61c-f514-402f-af4b-2401b588bfec\",\n        \"subtopic\": \"\",\n        \"persist_state\": true\n      }\n    ],\n    \"delta\": 1\n  }\n}\n</code></pre>"},{"location":"twins/#create","title":"Create","text":"<p>Create request uses POST HTTP method to create twin:</p> <pre><code>curl -s -S -i -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:9018/twins -d '&lt;twin_data&gt;'\n</code></pre> <p>If you do not suply the definition, the empty definition of the form</p> <pre><code>{\n    \"id\": 0,\n    \"created\": \"2020-05-05T08:41:39.142Z\",\n    \"attributes\": [],\n    \"delta\": 1000000\n}\n</code></pre> <p>will be created.</p>"},{"location":"twins/#update","title":"Update","text":"<pre><code>curl -s -S -i -X PUT -H \"Content-Type: application/json\" -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:9018/&lt;twin_id&gt; -d '&lt;twin_data&gt;'\n</code></pre>"},{"location":"twins/#view","title":"View","text":"<pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:9018/twins/&lt;twin_id&gt;\n</code></pre>"},{"location":"twins/#list","title":"List","text":"<pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:9018/twins\n</code></pre> <p>List requests accepts <code>limit</code> and <code>offset</code> query parameters. By default, i.e. without these parameters, list requests fetches only first ten twins (or less, if there are less then ten twins).</p> <p>You can fetch twins [10-29) like this:</p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:9018/twins?offset=10&amp;limit=20\n</code></pre>"},{"location":"twins/#delete","title":"Delete","text":"<pre><code>curl -s -S -i -X DELETE -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:9018/twins/&lt;twin_id&gt;\n</code></pre>"},{"location":"twins/#states-operations","title":"STATES operations","text":""},{"location":"twins/#list_1","title":"List","text":"<pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:9018/states/&lt;twin_id&gt;\n</code></pre> <p>List requests accepts <code>limit</code> and <code>offset</code> query parameters. By default, i.e. without these parameters, list requests fetches only first ten states (or less, if there are less then ten states).</p> <p>You can fetch states [10-29) like this:</p> <pre><code>curl -s -S -i -X GET -H \"Authorization: Bearer &lt;user_token&gt;\" http://localhost:9018/states/&lt;twin_id&gt;?offset=10&amp;limit=20\n</code></pre>"},{"location":"twins/#notifications","title":"Notifications","text":"<p>Every twin and states related operation publishes notifications via the message broker. To fully understand what follows, please read about Mainflux messaging capabilities and utilities.</p> <p>In order to pick up this notifications, you have to create a Mainflux channel before you start the twins service and inform the twins service about the channel by means of the environment variable, like this:</p> <pre><code>export MF_TWINS_CHANNEL_ID=f6894dfe-a7c9-4eef-a614-637ebeea5b4c\n</code></pre> <p>The twins service will use this channel to publish notifications related to twins creation, update, retrieval and deletion. It will also publish notifications related to state saving into the database.</p> <p>All notifications will be published on the following message broker subject:</p> <pre><code>channels.&lt;mf_twins_channel_id&gt;.&lt;optional_subtopic&gt;\n</code></pre> <p>where <code>&lt;optional_subtopic&gt;</code> is one of the following:</p> <ul> <li><code>create.success</code> - on successful twin creation,</li> <li><code>create.failure</code> - on twin creation failure,</li> <li><code>update.success</code> - on successful twin update,</li> <li><code>update.failure</code> - on twin update failure,</li> <li><code>get.success</code> - on successful twin retrieval,</li> <li><code>get.failure</code> - on twin retrieval failure,</li> <li><code>remove.success</code> - on successful twin deletion,</li> <li><code>remove.failure</code> - on twin deletion failure,</li> <li><code>save.success</code> - on successful state save</li> <li><code>save.failure</code> - on state save failure.</li> </ul> <p>Normally, you can use the default message broker, NATS, wildcards. In order to learn more about Mainflux channel topic composition, please read about subtopics. The point is to be able to subscribe to all subjects or any operation pair subject - e.g. create.success/failure - by means of one connection and read all messages or all operation related messages in the context of the same subscription.</p> <p>Since messages published on message broker are republished on any other protocol supported by Mainflux - HTTP, MQTT, CoAP and WS - you can use any supported protocol client to pick up notifications.</p>"}]}